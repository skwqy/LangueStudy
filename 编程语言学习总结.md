

# 前言

## 动态语言 vs 静态语言

### 概念

**动态语言（弱类型语言）**

- 运行时才确定数据类型的语言，变量在使用之前无需申明类型，通常变量的值是被赋值的那个值的类型。比如Php、Asp、JavaScript、Python、Perl等等。
- 必须强制确定数据类型的语言，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这种数据类型。一个变量的类型是申明的时候就已经确定的，更安全。

**静态语言（强类型语言）**

- 编译时变量的数据类型就可以确定的语言，大多数静态语言要求在使用变量之前必须生命数据类型。比如Java、C、C++、C#等。数据类型可以被忽略的语言。
- 它与强类型语言相反，一个变量可以赋不同数据类型的值。一个变量的类型是由其上下文决定的，效率更高。

### 区别

- 静态语言
  - 由于强制声明数据类型，让开发工具（IDE）对代码有很强的判断能力，在实现复杂的业务逻辑和开发大型商业系统、以及那些声明周期很长的应用中，开发者可以依托强大的IDE来更高效、更安全地开发。
  - 编译器可以执行各种检查，也就是程序还没跑起来就能找到一些小错误，也就是是在compile-time 检查出错误的。
- 动态语言
  - 思维不受约束，可以任意发挥，把更多的精力放在产品本身上；集中思考业务逻辑实现，思考过程就是实现过程。
  - 开发一个大型应用程序,有一个函数期望接收一个叫作 ID 的字段。这个参数应该是整数,是字符串,还是一个 UUID?要想知道答案,只能去看源代码。可以尝试使用一个数字或者字符串来执行这个函数,看看会发生什么。
  - 可能代码开发快，但是维护难（但是脚本语言平常写的代码量应该不太多，还比较好debug和修改）

# 一、语言基础

## 1、数据类型

### 1.1、类型概述

#### a、Java

在java语言中，变量分为两种：基本类型和引用类型。

基本数据类型是CPU可以直接进行运算的类型。Java定义了以下几种基本数据类型：

- 整数类型：byte、short、int、long
- 浮点数类型：float、double
- 字符类型：char
- 布尔类型：bool

#### b、Go

在Go语言中，数据类型用于声明函数和变量。

数据类型的出现是为了把数据分成所需内存大小不同的类型，编程的时候需要用大数据的时候才需要申请大内存，就可以充分利用内存。

所有类型都能赋值给interface{}空接口；GO语言中没有类的概念，只能通过struct和method来模拟；

Go语言按类别有以下几种数据类型：

1. 布尔型：bool
2. 数字类型：
   - 无符号整数：uint8、uint16、uint32、uint64
   - 有符号整数：int8、int16、int32、int64
   - 浮点数：float32、float64
   - 布尔：bool
   - 其它类型：
     - byte、uint8 ：两种类型可以互换，是一回事
     - rune、int32：两种类型可以互换，是一回事
     - int、uint：长度由CPU的位数决定(32或64位)、
     - uintptr：无符号整型，用于存放一个指针
   - 复数：complex64、conplex128
   - 字符：byte/uint8、rune 
     - uint8/byte代表ASCII的一个字符
     - rune代表一个UTF-8字符，代表中文、韩文等字符。
3. 字符串类型：string
4. 派生类型：
   - 指针类型（pointer）
   - 数组类型：
   - 结构体：struct
   - channel类型
   - 函数类型
   - 切片类型
   - 接口类型（interface）
   - Map类型

#### c、Python

Python中一切事物皆对象，变量是对对象在内存中的存储和地址的抽象。

变量就是变量，它没有类型；Python使用对象模型来存储数据，构造任何类型的值都是对象。对象都拥有三个特性：身份、类型、值。

身份：每个对象都有一个唯一的身份标识自己，任何对象的身份都可以通过内建函数id()来得到。

类型：对象的类型决定了对象可以保存什么类型的值，可以进行什么样的操作，以及遵循什么样的规则。可以通过type()查看对象类型。返回的是对象而不是简单的字符串。

值：对象表示的数据

Python3中有六个标准数据类型：

1. Number（数字）：int、float、bool、complex(复数)
2. String（字符串）
3. Tuple（元组）
4. List（列表）
5. Set（集合）
6. Dictionary（字典）

- 不可变数据类型：Number、String、Tuple
- 可变数据类型：List、Dictionary、Set

#### d、JavaScript

JavaScript变量均为对象。当声明一个变量时，就创建了一个新的对象。

JavaScript不区分整数和浮点数，统一使用Number表示。

值类型（基本类型）：String、Number、Boolean、Null、Undefined、Symbol

引用类型（对象类型）：Object、Array、Function、RegExp、Date

```javascript
console.log("------------------typeof-------------------------")
console.log(typeof 1)       // number
console.log(typeof 3.14)    // number
console.log(typeof 'abc')   // string
console.log(typeof "123")   // string
console.log(typeof true)    // boolean
console.log(typeof undefined)   // undefined
console.log(typeof function () {
})   // function
console.log(typeof [1, 2, 3])     // object
console.log(typeof new Array()) // object
console.log(typeof new Date())  // object
console.log(typeof null)        // object
console.log(typeof new Map())   // object
console.log(typeof new Set())   // object

// typeof 根本无法区分Object类型中的Array、Date、Map、Set等类型
// 使用Object.prototype.toString 可以解决此问题

console.log("------------------constructor.name-------------------------")
int1 = 1
console.log(int1.constructor.name)       // Number
console.log(3.14.constructor.name)    // Number
console.log('abc'.constructor.name)   // String
console.log("123".constructor.name)   // String
console.log(true.constructor.name)    // Boolean
// console.log(undefined)   // 无法使用constructor.name
console.log(function () {
}.constructor.name)   // Function
console.log([1, 2, 3].constructor.name)     // Array
console.log(new Array().constructor.name) // Array
console.log(new Date().constructor.name)  // Date
// console.log(null)        // 无法使用constructor.name
console.log(new Map().constructor.name)   // Map
console.log(new Set().constructor.name)   // Set
```



### 1.2、数据类型对比

| 类型       | Java                   | Go                                      | Python          | JavaScript      | 备注                                                         |
| ---------- | ---------------------- | --------------------------------------- | --------------- | --------------- | ------------------------------------------------------------ |
| byte       | byte                   | byte                                    |                 |                 |                                                              |
| bool       | bool                   | bool                                    | <class,bool>    |                 |                                                              |
| 有符号整数 | short/int/long         | int8/int16/int32/int64/int/rune         | <class,int>     |                 | Python bool继承int,可以当成int的0或1                         |
| 无符号整数 | --                     | uint8/uint16/uint32/uint64/uint/uintptr | --              |                 |                                                              |
| 浮点数     | float/double           | float32/float64                         | <class,float>   |                 |                                                              |
| 复数       | --                     | complex                                 | <class,complex> | --              |                                                              |
| 字符       | char                   | byte/uint8/rune                         | --              |                 | Go中字符有2种，uint8/byte代表ASCII的一个字符，rune代表一个UTF-8字符 |
| 指针       | --                     | pointer                                 | --              | --              |                                                              |
| 字符串     | String                 | string                                  | <class,str>     | String          |                                                              |
| 空         | null                   | nil                                     | None            | null、undefined |                                                              |
| 元组       | --                     | --                                      | <class,tuple>   | --              |                                                              |
| 数组       | Array                  | array                                   | --              | Array           |                                                              |
| List       | ArrayList/LinkedList等 | slice                                   | <class,list>    | List            |                                                              |
| Map        | HashMap/TreeMap等      | map                                     | <class,dict>    | Map             |                                                              |
| Set        | HashSet/TreeSet等      | --                                      | <class,set>     | Set             |                                                              |
| 结构体     | --                     | struct                                  | --              | --              |                                                              |
| 函数       | 成员函数               | func（函数和方法）                      | def             | Function        |                                                              |
| 接口       | Interface              | interface                               |                 | --              |                                                              |
| 类         | Class                  | --                                      | Class           | Class           |                                                              |
| Channel    | --                     | channel                                 | --              | --              |                                                              |

## 2、变量
### 2.1、变量声明(定义)

#### a、Java

```java
// 方式一： 数据类型 变量名 = 赋值;
// 方式二： var 变量名 = 赋值;  // JDK10 局部变量类型推断，可以使用var代替实际类型

String name = "skwqy";
int age = 100;
var name2 = "skwqy";
```

#### b、GO

```go
// 方式一： var 变量名 数据类型 = 赋值	  	// 完整形式
// 方式二： var 变量名 = 赋值           	// 类型推断，省略数据类型
// 方式三： 变量名 := 赋值			        	// 简短声明，省略var关键字

var name string = "skwqy"
var name = "skwqy"
name := "skwqy"
```

#### c、Python

```python
# Python中变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建
name = 'skwqy'
name2 = "sk"
x = 10
```

#### d、JavaScript

```javascript
// 方式一： var 变量名 = 赋值
// 方式二： let 变量名 = 赋值 （推荐）
// 方式三： const 变量名 = 赋值 （常量）
// let 声明的变量仅在块级作用域中有效。注意：let不允许在相同的作用域内，重复声明同一个变量。
// -------------------------------------------------
{
    let a = 10;
    var b = 1;
}
a // ReferenceError: a is not defined. 
b //1
// -------------------------------------------------
var a = [];
for (var i = 0; i < 10; i++) {
  var c = i;
  a[i] = function () {
    console.log(c);
  };
}
a[6](); // 9
// --------------------------------------------------
var a = [];
for (let i = 0; i < 10; i++) {
  let c = i;
  a[i] = function () {
    console.log(c);
  };
}
a[6](); // 6
```



### 2.2、常量

常量一旦声明，常量的值就不能改变。

#### a、Java

```java
// Java 常量使用final来修饰
public static final float PI = 3.14;
```

#### b、Go

```Go
// Go 常量使用const来修饰
const PI float32 = 3.14
const PI2 = 3.14
```

#### c、Python

```python
# Python 中没有定义常量的关键字，也不存在受编译器保护的常量
# 常量只是程序员之间的默契，不收解析器的保护：使用大写字母和下划线来表示常量
PI = 3.14
```

#### d、JavaScript

```javascript
const PI = 3.14
```

### 2.3、常用数据结构

#### 2.3.1、字符串



##### 1、字符串的声明和定义

###### a、Java

```java
// 方式一：字面量定义，常量池
String name = "字符串定义";
            
// 方式二：new 对象定义，堆中
String name2 = new String("字符串定义2");

// 方式三：局部变量推断,仅限于函数内部定义局部变量 JDK提供该功能
var name3 = "字符串定义3";

// 方式4：Text块 JDK14提供该功能
String names = """
        hello
        skwqy
        周峰
        """;
```

###### b、Go

```go
// 方式一：通过双引号创建字符串
var name string = "字符串"

// 方式二：通过反引号(``)来创建，也称为原始文本。不支持转义字符，可以跨越多行，可以包含除反引号之外的任何字符。
// 通常，它用于在正则表达式或HTML中编写多行消息。
var name2 string = `hello
skwqy`
```

###### c、Python

Python中没有字符类型，一个字符也是字符串。

```python
# 方式一： 单引号，单行,可以包含双引号
name = '我叫"老大哥"'
# 方式二： 双引号，单行，可以包含单引号
name2 = "请叫我'老大哥'"
# 方式三：三个单引号，多行，可以包含单、双引号
name3 = '''请叫我
"老大哥'你好'"'''
# 方式四： 三个双引号，多行，可以包含单、双引号
name4 = """请叫我
'老大哥'
"你好"
"""

# 原始字符串,字符串不会转义，原样输出
# 方式一：不能包含单引号(')
rname = r'test\t123'
# 方式一：不能包含双引号(")
rname2 = R"test\t123"
# 方式三：可以包含单、双引号
rname3 = r'''姓名'''
# 方式四：可以包含单、双引号
rname4 = R"""姓名"""
```

###### d、JavaScript

```javascript
// 方式一：单引号，字符串内容可以包含双引号
var name1 = '请叫我"老大哥"'

// 方式二：双引号，字符串内容可以包含单引号
let name2 = "请叫我'老大哥'"

// 方式三：反引号,多行字符串，可以包含单、双引号
const name3 = `请叫我
"老大哥"
'OK'`
```

##### 2、字符子串

###### a、Java

```java
String oriStr="012345678";
String sub1 = oriStr.substring(1);  // 12345678
String sub2=oriStr.substring(2,5);  // 234
```

###### b、Go

```go
var oriStr = "012345678"
println(oriStr[1:])  // 12345678
println(oriStr[2:5]) // 234
println(oriStr[:5])  // 01234
```

###### c、Python

```python
oriStr = "012345678"
print(oriStr[1:])   # 12345678
print(oriStr[2:5])  # 234
print(oriStr[:5])   # 01234
```

###### d、JavaScript

```javascript
let oriStr = "012345678"
console.log(oriStr.substring(1))        // 12345678
console.log(oriStr.substring(2,5))      // 234
```

##### 3、字符串分割

###### a、Java

```java
String oriStr="123:456:789";
String[] members = oriStr.split(":");
```

###### b、Go

```go
findStr := "123:456:789"
arr := strings.Split(findStr, ":")
fmt.Println(arr) // [123 456 789]
```

###### c、Python

```python
findStr = "123:456:789"
arr = findStr.split(":")
print(arr)  # ['123', '456', '789']
```

###### d、JavaScript

```javascript
findStr = "123:456:789"
arr = findStr.split(":")
console.log(arr)    // [ '123', '456', '789' ]
```

##### 4、字符串查找

###### a、Java

```java
String oriStr = "123:456:789:我爱中国";
int index = oriStr.indexOf(":");
System.out.println(oriStr.substring(index));        // :456:789:我爱中国
int lastIndex = oriStr.lastIndexOf(":");
System.out.println(oriStr.substring(lastIndex));    // :我爱中国
```

###### b、Go

```go
findSubStr := "123:456:789:我爱中国"
index := strings.IndexAny(findSubStr, ":")
fmt.Println(findSubStr[index:]) // :456:789:我爱中国
lastIndex := strings.LastIndexAny(findSubStr, ":")
fmt.Println(findSubStr[lastIndex:]) //:我爱中国
```

###### c、Python

```python
findSubStr = "123:456:789:我爱中国"
index = findSubStr.find(":")
print(findSubStr[index:])  # :456:789:我爱中国
lastIndex = findSubStr.rfind(":")
print(findSubStr[lastIndex:])  # :我爱中国
```

###### d、JavaScript

```javascript
findSubStr = "123:456:789:我爱中国"
index = findSubStr.indexOf(":")
console.log(findSubStr.substring(index)) // :456:789:我爱中国
lastIndex = findSubStr.lastIndexOf(":")
console.log(findSubStr.substring(lastIndex)) //:我爱中国
```



##### 5、字符替换

###### a、Java

```java

```

###### b、Go

```go

```

###### c、Python

```python

```

###### d、JavaScript

```javascript

```



#### 2.3.2、数组

Java和Go语言中的数组在创建时需要指定存放数据类型和数组大小，数组一旦创建，其大小是不能改变的。且数组中存放的数据类型也是确定的，虽然Go语言可以创建interface{}数组来存放任何数据类型（包含基本数据类型int8、uint8等）

Python和JavaScript这种动态语言中的数组在创建时，不需要指定大小和数据类型。无需指定大小这种特性更想Java中的List和Go中的切片Slice。

##### 1、数组创建

###### a、Java

```java
// 方式一：
String[] names = new String[3];
names[0] = "skwqy";
names[1] = "sk";
names[2] = "skwqy2";

String[] names1 = new String[]{"skwqy", "sk", "skwqy2"};
System.out.println(names1.length); // 3

// 方式二：
String[] names2 = {"skwqy", "sk", "skwqy2"};
System.out.println(names2.length);// 3
```

###### b、Go

```go
// 方式一：指定容量，创建
var names [3]string
names[0] = "小明"
names[1] = "王二狗"
fmt.Println(names)                  // [小明 王二狗 ]
fmt.Println(len(names), cap(names)) // 3 3

// 方式二：指定容量，创建并初始化
var name2 [3]string = [3]string{"王二狗", "李小花", "张三丰"}
fmt.Println(name2) // [王二狗 李小花 张三丰]

// 方式三：指定容量，按照索引进行初始化
name3 := [3]string{1: "郭靖", 2: "黄蓉"}
fmt.Println(name3) // [ 郭靖 黄蓉]

// 方式四：匹配容量，
name4 := [...]string{"0", "1", "2", "3"}
fmt.Println(name4)                  // [0 1 2 3]
fmt.Println(len(name4), cap(name4)) // 4 4

// 方式五：匹配容量，指定索引
name5 := [...]string{0: "姓名0", 6: "姓名6"}
fmt.Println(name5)                  // [姓名0      姓名6]
fmt.Println(len(name5), cap(name5)) // 7 7
```

###### c、Python

```python
# Python 中没有数组的概念
```

###### d、JavaScript

```javascript
// JavaScript中的数组更向Java中的List，Go中的Slcie，放到List结构中进行对比
```



##### 2、数组遍历

###### a、Java

```java
String[] names = {"欧阳修", "苏轼", "王安石"};
// 方式一：
for (int index = 0; index < names.length; index++) {
    var name = names[index];
    System.out.println(name);
}

// 方式二：
for(var name:names){
    System.out.println(name);
}

// 方式三：
Arrays.stream(names).forEach(name-> System.out.println(name));
```

###### b、Go

```go
namess := [...]string{"欧阳修", "苏轼", "王安石"}
// 方式一
for i := 0; i < len(namess); i++ {
	fmt.Println(namess[i])
}

// 方式二
for index, name := range namess {
	fmt.Println(index, name)
}
```

###### c、Python

```python
# Python 中没有数组的概念
```

###### d、JavaScript

```javascript
// JavaScript中的数组更向Java中的List，Go中的Slcie，放到List结构中进行对比
```

#### 2.3.3、List 切片

Java中的List是定义为接口，jdk包括用户都可以基于该接口实现自己的List实现类。当前Java中实现List接口的数据结构有：

- ArrayList：非线程安全，底层数组数组实现
- LinkedList：非线程安全，底层使用链表实现
- CopyOnWriteArrayList：线程安全
- ......

Go、Python、JavaScript的类List都是编程语言内置的，Go语言的Slice、Python的<class 'list'>、JavaScript的Array都是语言内置的，提供容量动态增长特性，并提供丰富的操作接口。

##### 1、创建

###### a、Java

```java
// 方式一：
var list1 = new ArrayList<>(20);

// 方式二：
var list2 = Arrays.asList("王安石", "苏轼");

// 方式三：
var list3 = List.of("王安石", "苏轼");

// 方式四：
var list4 = Stream.of("王安石", "苏轼").toList();
```

###### b、Go

```go
// 1. 数组
var arr [3]string

// 2.切片
// 方式一：
var s1 []string                                 // 注意没有长度，有长度的是数组，没有长度的是切片slice
fmt.Printf("容量:%d， 长度:%d \n", cap(s1), len(s1)) // 容量:0， 长度:0

// 方式二：和方式一没啥区别，就是创建并初始化
s2 := []string{"王安石", "苏轼"}
fmt.Printf("容量:%d， 长度:%d \n", cap(s2), len(s2)) // 容量:2， 长度:2
fmt.Printf("%T,%T\n", arr, s2)                  // [3]string,[]string

// 方式三：指定长度和容量
s3 := make([]string, 3, 8)
fmt.Printf("容量:%d， 长度:%d \n", cap(s3), len(s3)) // 容量:8， 长度:3

// 特殊情况，如果切片类型为interface{}时，可以存放任意的数据类型
s4 := []interface{}{1, 2, 3.14, "王安石"}
fmt.Println(s4) // [1 2 3.14 王安石]
```

###### c、Python

```python
# Python的List中可以存放任意类型的数据
names = ["王安石", "苏轼", 10, True, [1, 2]]
print(names) # ['王安石', '苏轼', 10, True, [1, 2]]
```

###### d、JavaScript

```javascript
// JavaScript 的Array可以包含任意数据类型

// 方式一：推荐
let arr = [1, 2, 3.14, 'Hello', null, true, [2, false, 'sk']]
console.log(arr) // [ 1, 2, 3.14, 'Hello', null, true, [ 2, false, 'sk' ] ]

// 方式二：不推荐
let arr2 = new Array()  // 不推荐
console.log(arr2) // []
```

##### 2、遍历

###### a、Java

```java
var names = Arrays.asList("王安石", "苏轼");
// 方式一：
for (int i = 0, len = names.size(); i < len; i++) {
    System.out.println(names.get(i));
}

// 方式二：
var ite = names.iterator();
while (ite.hasNext()) {
    System.out.println(ite.next());
}

// 方式三
for(var name:names){
    System.out.println(name);
}
```

###### b、Go

```go
names := []string{"王安石", "苏轼"}
// 方式一
for i := 0; i < len(names); i++ {
	fmt.Println(names[i])
}

// 方式二
for index, name := range names {
	fmt.Println(index, name)
}
```

###### c、Python

```python
names = ["王安石", "苏轼"]

# 方式一
for name in names:
    print(name)

# 方式二：带有index (0, '王安石') (1, '苏轼')
for name in enumerate(names):
    print(name)

# 方式三：
for name in iter(names):
    print(name)

# 方式四
for i in range(len(names)):
    print(i, names[i])
```

###### d、JavaScript

```javascript
let names = ["王安石", "苏轼"]
// 方式一：for/while 根据数组长度遍历
for (let i = 0, len = names.length; i < len; i++) {
    console.log(names[i])
}

// 方式二： for...in 可以遍历对象/数组。遍历数组时也会遍历非数字键名，所以不推荐for...in遍历数组
for (let key in names) {
    console.log(names[key])
}

// 方式三：for...of (ES6)
for(let name of names){
    console.log(name)
}

// 方式四：forEach()方法
names.forEach(name=>console.log(name))
```

##### 3、增删改

###### a、Java

```java
var names = new ArrayList<String>();
// 1. 添加元素
names.add("王安石");  // 方式一：添加到末尾
names.add(0, "苏轼"); // 方式二：添加到指定位置
System.out.println(names); // [苏轼, 王安石]

// 2. 删除元素
names.remove("王安石");  // 方式一：根据元素
System.out.println(names); // [苏轼]
names.remove(0); // 方式二：根据索引
System.out.println(names); // []
names.add(0, "欧阳修");
var ite = names.iterator();
while (ite.hasNext()) {
    String name = ite.next();
    if ("欧阳修".equals(name)) {
        ite.remove();   // 方式三：使用迭代器删除
    }
}
System.out.println(names); // []

// 3. 修改元素
names.add("王安石");  // [王安石]
System.out.println(names);
names.set(0, "欧阳修");
System.out.println(names); // [欧阳修]
```

###### b、Go

```go
// 1. 增加元素
names = []string{}
names = append(names, "王安石", "曾巩")             // 方式一：在末尾插入
fmt.Printf("指向地址:%p， 切片内容：%s\n", names, names) //指向地址:0xc00005a060， 切片内容：[王安石 曾巩]
names = append(names[:1], "苏轼")                // 方式二：在指定位置插入，插入时会覆盖后面位置元素
fmt.Printf("指向地址:%p， 切片内容：%s\n", names, names) //指向地址:0xc00005a060， 切片内容：[王安石 苏轼]

// 2. 删除元素
names = append(names, "柳宗元")
fmt.Printf("指向地址:%p， 切片内容：%s\n", names, names) // 指向地址:0xc0000200c0， 切片内容：[王安石 苏轼 柳宗元]
names = append(names[:1], names[2:]...)        // 删除第二个元素 [0,1)+[2,结束+1)
fmt.Printf("指向地址:%p， 切片内容：%s\n", names, names) // 指向地址:0xc0000200c0， 切片内容：[王安石 柳宗元]

// 3. 修改元素
names[1] = "李元龙"
fmt.Println(names) // [王安石 李元龙]
```

###### c、Python

```python
names = ["王安石"]
# 1. 增加元素
names.append("苏轼")  # 方式一：在末尾添加
names.insert(0, "柳宗元")  # 方式二：在指定位置添加
print(names)  # ['柳宗元', '王安石', '苏轼']

# 2. 删除元素
names.pop()  # 方式一：在末尾删除
print(names)  # ['柳宗元', '王安石']
names.pop(0)  # 方式二：在指定位置删除
print(names)  # ['王安石']

# 3. 修改元素
names[0] = "周润发"
print(names)  # ['周润发']
```

###### d、JavaScript

```javascript
names = ["王安石"]
// 1. 增加元素
names.push("苏轼")    // 方式一：在末尾添加元素
names.unshift("柳宗元") // 方式二：在头部增加元素
console.log(names)  // [ '柳宗元', '王安石', '苏轼' ]

// 2. 删除元素
names.pop()  // 方式一：从末尾删除元素
names.shift()   // 方式二：从头部删除数据
console.log(names) // [ '王安石' ]

// 3. 修改元素
names[0] = "周润发"
console.log(names)  // [ '周润发' ]
```

##### 4、排序

###### a、Java

```java
var numbers = Arrays.asList(4, 6, 8, 9, 1, 2);
numbers.sort((e1, e2) -> e1.compareTo(e2));
System.out.println(numbers); // [1, 2, 4, 6, 8, 9]
```

###### b、Go

```go
numbers := []int{4, 6, 8, 9, 1, 2}
sort.Ints(numbers)
fmt.Println(numbers) // [1 2 4 6 8 9]
```

###### c、Python

```python
numbers = [4, 6, 8, 9, 1, 2]
numbers.sort()
print(numbers)  # [1, 2, 4, 6, 8, 9]
```

###### d、JavaScript

```javascript
numbers = [4, 6, 8, 9, 1, 2, 2]
numbers.sort()
console.log(numbers)    // [ 1, 2, 2, 4, 6, 8, 9 ]
numbers.sort((a, b) => {
    if (a > b) {
        return -1;
    } else if (a < b) {
        return 1
    } else {
        return 0;
    }
})
console.log(numbers)  // [9, 8, 6, 4, 2, 2, 1]
```

#### 2.3.3、Map 字典

Java中的Map是定义为接口，jdk包括用户都可以基于该接口实现自己的Map实现类。当前Java中实现Map接口的数据结构有：

- Hashtable：线程安全；对象锁，所有方法sync
- HashMap：非线程安全；允许存在一条键为null的记录；底层实现为数组+链表(可演变为红黑树)
- TreeMap：非线程安全；不允许key为null；按key进行排序，可以自定义Comparator
- LinkedHashMap：非线程安全；保证插入的顺序
- ConcurrentHashMap：线程安全；采用分段锁
- ConcurrentSkipListMap：线程安全；默认按照key值升序；
- ......

参考： https://www.cnblogs.com/www-123456/p/10890855.html

Go、Python、JavaScript的类Map都是编程语言内置的，Go语言的map、Python的<class 'dict'>、JavaScript的Map都是语言内置的，提供容量动态增长特性，并提供丰富的操作接口。

JavaScript优先使用Map/Set：在试图将对象或数组用作查找的场合，建议优先使用ES6支持的Map/Set替代。Map/Set不需要规避特殊的键名（key），并且可以将字符串之外的其它数据类型也用作key，从而支持更丰富的查找操作。

##### 1、创建

###### a、Java

```java
// 方式一：
final Map<String, String> nameAlis = new HashMap<>();
nameAlis.put("苏轼", "东坡居士");
nameAlis.put("诸葛亮", "孔明");

// 方式二：
final Map<String, String> nameAlis2 = new HashMap<>() {{
    put("苏轼", "东坡居士");
    put("诸葛亮", "孔明");
}};

// 方式三：JDK9
final Map<String, String> nameAlis3 = Map.of("苏轼", "东坡居士", "诸葛亮", "孔明");
```

###### b、Go

```go
// 方式一：先声明，在创建
var nameAlias map[string]string // 只有声明，没有初始化，值为nil
nameAlias = make(map[string]string)
nameAlias["苏轼"] = "东坡居士"
nameAlias["诸葛亮"] = "孔明"

// 方式二：
var nameAlias2 = map[string]string{"苏轼": "东坡居士", "诸葛亮": "孔明"}
fmt.Println(nameAlias2) // map[苏轼:东坡居士 诸葛亮:孔明]
```

###### c、Python

```python
nameAlias = {"苏轼": "东坡居士"}
nameAlias["诸葛亮"] = "孔明"
print(nameAlias) // {'苏轼': '东坡居士', '诸葛亮': '孔明'}
```

###### d、JavaScript

```javascript
// 方式一：推荐
nameAlias = new Map()
nameAlias.set("苏轼", "东坡居士")
nameAlias.set("诸葛亮", "孔明")
nameAlias["周润发"] = "发哥"

console.log(nameAlias.constructor) // [Function: Map]
console.log(nameAlias)
// Map(2) { '苏轼' => '东坡居士', '诸葛亮' => '孔明', '周润发': '发哥' }
// 2：表示Map对象有两个元素，key分别是苏轼、诸葛亮。 周润发这个属性是作为Object属性，并不是Map的key


// 方式二：推荐
nameAlias = new Map([["苏轼","东坡居士"],["诸葛亮","孔明"]])
nameAlias.set(100, "周润发")
console.log(nameAlias)
// Map(3) { '苏轼' => '东坡居士', '诸葛亮' => '孔明', 100 => '周润发' }

// 方式三： 类似Map，但其实是Object
nameAlias2 = {"苏轼": "东坡居士"}
nameAlias2["诸葛亮"] = "孔明"
console.log(nameAlias2.constructor)  // [Function: Object]
console.log(nameAlias2)  // { '苏轼': '东坡居士', '诸葛亮': '孔明' }
```

##### 2、遍历

###### a、Java

```java
final Map<String, String> nameAlis = new HashMap<>();
nameAlis.put("苏轼", "东坡居士");
nameAlis.put("诸葛亮", "孔明");

// 方式一：推荐
for (var item : nameAlis.entrySet()) {
    System.out.println(item.getKey() + ":" + item.getValue());
}

// 方式二：不推荐
for (var key : nameAlis.keySet()) {
    System.out.println(key + ":" + nameAlis.get(key));
}

// 方式三：
nameAlis.forEach((key, value) -> System.out.println(key + ":" + value));
```

###### b、Go

```go
var nameAlias3 = map[string]string{"苏轼": "东坡居士", "诸葛亮": "孔明"}
for k, v := range nameAlias3 {
	fmt.Println(k, ":", v)
}
```

###### c、Python

```python
nameAlias = {"苏轼": "东坡居士", "诸葛亮": "孔明"}
# 方式一：
for key in nameAlias:
    print(key + ":" + nameAlias[key])

# 方式二 推荐
for key, value in nameAlias.items():
    print(key + ":" + value)
```

###### d、JavaScript

```javascript
nameAlias3 = new Map([["test", "testValue"]])
nameAlias3.set("苏轼", "东坡居士")
nameAlias3.set("诸葛亮", "孔明")
nameAlias3["周润发"] = "发哥"

// 方式一：能遍历Map中的key和value，无法遍历Object的key、value属性
for (let item of nameAlias3) {
    console.log(item[0] + ":" + item[1])
}

// 方式二：能遍历Map中的key和value，无法遍历Object的key、value属性
nameAlias3.forEach(function (value, key, map) {
    console.log(key + ":" + value)
})

// 无法遍历Map中的key和value，能遍历Object的key、value属性
for (let key in nameAlias3) {
    console.log(key + ":" + nameAlias3[key])
}
```

##### 3、增删查

###### a、Java

```java
final Map<String, String> nameAlis = new HashMap<>();

// 1. 增加key/value
nameAlis.put("苏轼", "东坡居士"); // 方式一：有就覆盖，没有就增加
nameAlis.putIfAbsent("苏轼", "苏轼"); // 方式二：如果key不存在就添加，存在就不增加
// 方式三：如果不存在，就给他计算出一个值，并put进去
nameAlis.computeIfAbsent("周润发", (key) -> key + "发哥");
// 方式四：如果以及存在，重新计算出一个值，并put进去，key不变
nameAlis.computeIfPresent("苏轼", (key, value) -> key + value);
System.out.println(nameAlis); // {周润发=周润发发哥, 苏轼=苏轼东坡居士}
// 方式五：
//nameAlis.compute("周慧敏",)
// 方式六：
//nameAlis.putAll();

// 2. 删除
nameAlis.remove("周慧敏");
nameAlis.remove("周慧敏", "周慧敏");

// 3. 查询
nameAlis.get("周慧敏");
nameAlis.getOrDefault("周慧敏", "默认值周慧敏");
```

###### b、Go

```go
var nameAlias4 = map[string]string{}
// 1. 增加
nameAlias4["苏轼"] = "东坡居士" // key不存在则增加，否则修改
nameAlias4["诸葛亮"] = "孔明"

// 2. 删除
delete(nameAlias4, "苏轼")

// 3. 查询
alias := nameAlias4["诸葛亮"]      // 方式一：直接获取
alias2, ok := nameAlias4["诸葛亮"] // 方式二：判断获取
if ok {
	fmt.Println(alias2)
}
fmt.Println(alias)
fmt.Println(nameAlias4)
```

###### c、Python

```python
# 1. 增加
nameAlias2 = {"诸葛亮": "孔明"}  # 方式一：创建就增加
nameAlias2["苏轼"] = "东坡居士"  # 方式二：添加

# 2. 删除
nameAlias2.pop("诸葛亮")

# 3. 获取
nameAlias2["苏轼"]  # 方式一：不推荐，如果key不存在，会抛TypeError异常
nameAlias2.get("苏轼")  # 方式二：推荐，如果可以不存在，返回None
nameAlias2.get("诸葛亮", "孔明")  # 方式三：推荐，如果key不存在，返回指定的值
```

###### d、JavaScript

```javascript
nameAlias = new Map()
// 1.增加
nameAlias.set("苏轼", "东坡居士")
nameAlias.set("诸葛亮", "孔明")

// 2.删除
nameAlias.delete("诸葛亮")

// 3.查询
nameAlias.has("苏格兰")  // 判断是是否存在
nameAlias.get("苏格兰")  // 如果不存在，返回 undefined
```

#### 2.3.4、Set 集合

Java中的Set是定义为接口，jdk包括用户都可以基于该接口实现自己的Set实现类。当前Java中实现Set接口的数据结构有：

- HashSet：非线程安全；不允许重复元素；允许null值；元素无序；
- TreeSet：非线程安全；不允许重复元素；允许null值；元素有序（按key排序）；
- LinkedHashSet：非线程安全；保证插入的顺序
- ConcurrentSkipListSet：线程安全；默认按照key值升序；
- ......

Go、Python、JavaScript的类Set都是编程语言内置的，Go语言没有内置set结构、Python的<class 'set'>、JavaScript的Set都是语言内置的，提供容量动态增长特性，并提供丰富的操作接口。

JavaScript优先使用Map/Set：在试图将对象或数组用作查找的场合，建议优先使用ES6支持的Map/Set替代。Map/Set不需要规避特殊的键名（key），并且可以将字符串之外的其它数据类型也用作key，从而支持更丰富的查找操作。

##### 1、创建

###### a、Java

```java
// 方式一
var names=new HashSet<String>();
names.add("苏轼");
names.add("王安石");
names.add("周润发");
names.add("王安石");
System.out.println(names); // [王安石, 周润发, 苏轼]
```

###### b、Go

```go
// Go语言没有内置set这种数据结构
```

###### c、Python

```python
# 方式一：
names = set()
names.add("苏轼")
names.add("王安石")

# 方式二：
names = set(["周润发", "周慧敏"])
names.add("周润发")
print(names)  # {'周慧敏', '周润发'}
```

###### d、JavaScript

```javascript
// 方式一：
names = new Set()
names.add("苏轼")
names.add("王安石")
names.add("王安石")
console.log(names)  // Set(2) { '苏轼', '王安石' }

// 方式二：
names = new Set(["苏轼", "周润发"])
console.log(names)  // Set(2) { '苏轼', '周润发' }
```



##### 2、遍历

###### a、Java

```java
var names=new HashSet<String>();
names.add("苏轼");
names.add("王安石");
names.add("周润发");
names.add("王安石");

// 方式一：
for(var name:names){
    System.out.println(name);
}

// 方式二：
var ite = names.iterator();
while(ite.hasNext()){
    var name = ite.next();
    System.out.println(name);
}

// 方式三：
names.forEach(name-> System.out.println(name));

// 方式四：
names.stream().forEach(name-> System.out.println(name));
```

###### b、Go

```go
// Go语言没有内置set这种数据结构
```

###### c、Python

```python
# 方式1：
for name in names:
    print(name)

# 方式2：
for name in iter(names):
    print(name)

# 方式3：
for index, name in enumerate(names):
    print(name)
```

###### d、JavaScript

```javascript
// 方式1：
for(let name of names){
    console.log("方式1：",name)
}

// 方式2：
names.forEach(name=>console.log("方式2：",name))

// 方式3：
for(let name of names.keys()){
    console.log("方式3：",name)
}

// 方式4：
for(let name of names.values()){
    console.log("方式4：",name)
}

// 方式5：
for(let item of names.entries()){
    console.log("方式5：",item[0],"-",item[1]) //方式5： 苏轼 - 苏轼
}
```

##### 3、增删改查

###### a、Java

```java
// 1.增加
names.add("苏轼");       // 方式1：
names.addAll(List.of("王安石","柳宗元")); // 方式2：
System.out.println(names); // [王安石, 苏轼, 柳宗元]

// 2.删除
names.remove("苏轼");
```

###### b、Go

```go
// Go语言没有内置set这种数据结构
```

###### c、Python

```python
names = set()
# 1. 添加
names.add("周润发")  # 方式1：单个添加
names.update({"周慧敏", "周星驰"})  # 方式2：批量添加，参数可迭代即可
names.update(["周总理", "周星驰"])
print(names)  # {'周总理', '周慧敏', '周润发', '周星驰'}

# 2. 删除
names.remove("周慧敏")  # 方式1：如果元素不存在时，会引发KeyError错误
names.discard("周慧敏")  # 方式2：元素不存在时，不会引发任何错误
names.pop()  # 方式3：随机删除并返回一个元素，set为空会引发KeyError
names.clear()  # 方式4：移除set中所有元素
```

###### d、JavaScript

```javascript
names = new Set()
// 1.增加
names.add("周润发")
console.log(names)  // Set(1) { '周润发' }

// 2.删除
names.delete("周润发")
console.log(names)  // Set(0) {}
```

#### 2.3.5、元组

## 3、字符串和编码

Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。现代操作系统和大多数编程语言都直接支持Unicode。

ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。

如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。

所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的`UTF-8`编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间：

| 字符 | ASCII    | Unicode           | UTF-8                      |
| :--- | :------- | :---------------- | :------------------------- |
| A    | 01000001 | 00000000 01000001 | 01000001                   |
| 中   | 不存在   | 01001110 00101101 | 11100100 10111000 10101101 |

**在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。**

参考： https://www.liaoxuefeng.com/wiki/1016959663602400/1017075323632896

## 4、程序结构

### 4.1、条件判断

### 4.2、选择结构

### 4.2、循环结构

# 二、函数/方法
## 1、函数和方法

**函数**：是一段代码，通过名字来进行调用。它能将一些数据（参数）传递进去进行处理，然后返回一些数据（返回值），也可以没有返回值。所有传递给函数的数据都是显式传递的。

**方法**：也是一段代码，也通过名字来进行调用，但它跟一个对象相关联。方法和函数大致上是相同的，但有两个主要的**不同之处**：

1. 方法中的数据是隐式传递的；

   方法在C++中被称为成员函数。方法和函数的区别就是成员函数和函数的区别；

   Java语言只有方法；只有静态方法和方法的区别；

   C语言中只有函数；

2. 方法可以操作类内部的数据（请记住，对象是类的实例化–类定义了一个数据类型，而对象是该数据类型的一个实例化）

## 2、函数的定义和调用

### 2.1、函数/方法定义&调用

#### a、Java

```java
/**
 * 定义方法的语法：
 * 返回值 方法名(参数){
 *     语句块;
 *     return 返回值;
 * }
 */
public class MethodDef {
    // 静态成员变量
    private static String localName = "sk";

    // 对象变量
    private String nickName = "skwqy";

    // 方式一：静态方法
    public static String hello() {
        return "Hello World";
    }

    // 方式二：成员方法
    public String hi(String name) {
        return "Hi," + name;
    }

    public static void main(String[] args) {
        System.out.println(MethodDef.hello());
        MethodDef methodDef = new MethodDef();
        System.out.println(methodDef.hi("sk"));
    }
}
```

#### b、Go

```go
/**
定义函数的语法
	func funcName(param1 type1, param2 type2)(output1 out1，output2 out2){
		//......
		return value1，value2
	}
	A:func，定义函数的关键字
	B:funcName，函数名字
	C:(),函数的标志
	D:参数列表：形式参数用于接收外部传入函数中的数据
	E:返回值列表：函数执行后返回给调用处的结果。如果只有一个返回值，可以省略返回值的括号

	方法：method
		一个方法就是一个包含了接受者的函数，接受者可以是命名类型或结构体类型的一个值或者是一个指针。
		所有给定类型的方法属于该类型的方法集

	语法：
		func (接受者) 方法名(参数列表)(返回值列表){

		}

	总结：method，同函数类似，区别需要有接受者。（也就是调用者）

	方法 vs 函数
		A:意义
			方法：某个类别的行为功能，需要指定接受者调用
			函数：一段独立功能的代码，可以直接调用

		B:语法
			方法：方法名可以相同，只要接受者不同
			函数：命名不能冲突
*/
// 函数定义1
func hello(name string) string {
	return "hello " + name
}

// 函数定义2
func hello2() (string, int) {
	return "hello sk", 0
}

// Worker 方法定义
// 1.定义一个工人结构体
type Worker struct {
	name string
	age  int
	sex  string
}

// 2.定义行为方法
func (w Worker) work() {
	fmt.Println(w.name, "在工作...")
}

// 函数/方法调用
func main() {
	fmt.Println(hello("skwqy")) // hello skwqy

	w1 := Worker{name: "王二狗", age: 30, sex: "男"}
	w1.work() // 王二狗 在工作...
}

```

#### c、Python

```python
# 函数定义
def hello(name):
    return "hello " + name


class Person:
    # 构造函数
    def __init__(self, name):
        self.name = name

    # 成员方法
    def hi(self):
        return "hi " + self.name


if __name__ == '__main__':
    print(hello("skwqy"))  # hello skwqy
    person = Person("sk")
    print(person.hi())  # hi sk

```

#### d、JavaScript

```javascript
function hello(name) {
    return "hello " + name;
}

class Person {
    constructor(name) {
        this.name = name;
    }

    hi() {
        return "hi " + this.name;
    }
}

// 调用
console.log(hello("skwqy")) // hello skwqy
person = new Person("sk")
console.log(person.hi()) // hi sk
```

## 3、函数的参数和返回值

### 3.1、形式参数 vs 实际参数

- 形式参数（形数）：**函数定义**的时候，用于接收外部传入的数据变量。函数中，某些变量的数值无法确定，需要由外部传入数据。
- 实际参数（实数）：**函数调用**的时候，给形参赋值的实际的数值

### 3.2、参数传递方式（实参-->形参）

- **值传递**：形参是实参的拷贝，改变形参的值并不会影响外部实参的值；从函数调用的角度来说，值传递是单向的（实参-->形参），参数的值只能传入，不能传出；当函数内部需要修改参数，并且不希望这个改变影响调用者时，采用值传递。

- **引用传递**：形参相当于实参的“别名”，对形参的操作其实就是对实参的操作，在引用传递过程中，被调函数的形参虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参的任何操作都影响了主调函数中的实参变量。

- **指针传递**：形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作；

  | 语言       | 值传递 | 引用传递 | 指针传递 |
  | ---------- | ------ | -------- | -------- |
  | Java       | 支持   | 支持     | --       |
  | Go         | 支持   | 支持     | 支持     |
  | Python     | --     | 支持     | --       |
  | JavaScript | 支持   | 支持     | --       |

  | 语言       | 值传递                                           | 引用传递                                                   | 指针传递   |
  | ---------- | ------------------------------------------------ | ---------------------------------------------------------- | ---------- |
  | Java       | int、float、bool、char                           | 对象传递                                                   | --         |
  | Go         | array、int、float、string、bool、struct、complex | slice、map、chan                                           | 参数为指针 |
  | Python     | --                                               | 可变对象(list、dict、set)不可变对象(number、string、tuple) | --         |
  | JavaScript | 布尔、null、undefined、String、Number            | Array、Function、Object                                    | --         |

### 3.3、形参分类

形参分类：必选参数（位置参数）、默认参数、可变参数、命名关键字参数、关键字参数

- 必选参数：函数调用时，在指定的形参位置必须要传递对应的实参。
- 默认参数：在指定的形参位置如果未传递对应的实参，此时将形参赋值为一个默认值。
- 可变参数：传入的参数个数是可变的（可以传入0个或任意个参数）。这些参数在函数调用时自动组装成数组或tuple。
- 命名关键字参数：可以传入任意不受限制的关键字参数。
- 关键字参数：运行你传入0个或任意个含参数名的参数（key/value），这些关键字参数在函数内部自动组装称为一个dict。

| 语言       | 必选参数 | 默认参数 | 可变参数 | 命名关键字参数 | 关键字参数 |
| ---------- | -------- | -------- | -------- | -------------- | ---------- |
| Java       | 支持     | --       | 支持     | --             | --         |
| Go         | 支持     | --       | 支持     | --             | --         |
| Python     | 支持     | 支持     | 支持     | 支持           | 支持       |
| JavaScript | 支持     | 支持     | 支持     | --             | --         |

#### a、Java

```java
// Java 不知默认参数、关键字参数、命名关键字参数
// JDK 中的可变参数
package java.util;
public interface List<E> extends Collection<E> {
	static <E> List<E> of(E... elements) {
        switch (elements.length) { // implicit null check of elements
            case 0:
                @SuppressWarnings("unchecked")
                var list = (List<E>) ImmutableCollections.EMPTY_LIST;
                return list;
            case 1:
                return new ImmutableCollections.List12<>(elements[0]);
            case 2:
                return new ImmutableCollections.List12<>(elements[0], elements[1]);
            default:
                return ImmutableCollections.listFromArray(elements);
        }
    }
}
```

#### b、Go

```go
// Go不支持默认参数、关键字参数、命名关键字参数
// 可变参数
func getSum(num1 int, nums ...int) int {
	sum := num1
	for i := 0; i < len(nums); i++ {
		sum += nums[i]
	}
	return sum
}

func main() {
	fmt.Println(getSum(1, 2, 3, 4)) //10
}
```

#### c、Python

```python
# coding:utf-8
# https://www.liaoxuefeng.com/wiki/1016959663602400/1017261630425888
# --------------------------默认参数-------------------------------
# 默认参数: 用来计算x的n次方，由于我们经常计算平方，所以默认第二个参数n的默认值设定为2
def power(x, n=2):
    s = 1
    while n > 0:
        n = n - 1
        s = s * x
    return s


print(power(2, 2))  # 4
print(power(2, 3))  # 8


# --------------------------可变参数-------------------------------
# 参数为list
def get_sum(numbers):
    number_sum = 0
    for n in numbers:
        number_sum += n
    return number_sum


print(get_sum([1, 2, 3, 4]))  # 10


# 可变参数版本,和定义一个list或tuple参数相比，仅仅在前面加了一个*号
# 在函数内部，参数numbers接收到的是一个tuple
def get_sum2(*numbers):
    number_sum = 0
    for n in numbers:
        number_sum += n
    return number_sum


print(get_sum2(1, 2, 3, 4))  # 10


# --------------------------关键字参数------------------------------
# 关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数会在函数内部自动组装为一个dict
def person(name, age, **kw):
    print("name:", name, "age:", age, "other:", kw)


person("sk", 20)  # name: sk age: 20 other: {}
person("sk", 20, city="NanJing", job="Engineer")  # name: sk age: 20 other: {'city': 'NanJing', 'job': 'Engineer'}
# 和可变参数类似，也可以先组装出一个dict，然后把dict转换为关键字参数闯进去
extra = {'city': 'NanJing', 'jbo': 'Engineer'}
person('sk', 20, **extra)  # name: sk age: 20 other: {'city': 'NanJing', 'jbo': 'Engineer'}


# **extra表示把extra这个dict的所有key-value用关键字参数传入到函数的**kw参数，kw将获得一个dict
# 注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra

# --------------------------命名关键字参数---------------------------
# 方式1：如果没有可变参数，必须增加一个*作为特殊分隔符
def person(name, age, *, city, job):
    print(name, age, city, job)


# person('sk', 20) # TypeError: person() missing 2 required keyword-only arguments: 'city' and 'job'
person('sk', 20, city='NanJing', job="Engineer")  # sk 20 NanJing Engineer


# 方式2：如果有可变参数，跟着的命名关键字参数就不再需要一个特殊的分隔符*了
def person(name, age, *args, city, job):
    print(name, age, city, job)


person('sk', 20, 20, 20, city='NanJing', job='Engineer')  # sk 20 NanJing Engineer


# 方式3：命名关键字可以有缺省值
def person(name, age, *, city='NanJing', job):
    print(name, age, city, job)


person('sk', 20, job='Engineer')  # sk 20 NanJing Engineer


# --------------------------参数组合---------------------------
# 在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数、命名关键字参数，这5中参数都可以组合使用。
# 但是必须注意参数定义的顺序必须是：必选参数、默认参数、可变桉树、命名关键字参数、关键字参数；

# 必选参数、默认参数、可变参数、关键字参数
def f1(a, b, c=0, *args, **kw):
    print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)


# 必须参数、默认参数、命名关键字参数、关键字参数
def f2(a, b, c=0, *, d, **kw):
    print('a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw)


f1(1, 2)  # a = 1 b = 2 c = 0 args = () kw = {}
f1(1, 2, c=3)  # a = 1 b = 2 c = 3 args = () kw = {}
f1(1, 2, 3, 'a', 'b')  # a = 1 b = 2 c = 3 args = ('a', 'b') kw = {}
f1(1, 2, 3, 'a', 'b', x=99)  # a = 1 b = 2 c = 3 args = ('a', 'b') kw = {'x': 99}
f2(1, 2, d=99, ext=None)  # a = 1 b = 2 c = 0 d = 99 kw = {'ext': None}

# 最神奇的是通过一个tuple和dict，你也可以调用上述函数
print("------------------------------------")
args = (1, 2, 3, 4)
kw = {'d': 99, 'x': '#'}
f1(*args, **kw)  # a = 1 b = 2 c = 3 args = (4,) kw = {'d': 99, 'x': '#'}
args = (1, 2, 3)
kw = {'d': 88, 'x': '#'}
f2(*args, **kw)  # a = 1 b = 2 c = 3 d = 88 kw = {'x': '#'}
```

#### d、JavaScript

```javascript
// ----------------------------默认参数-------------------------------
function log(x, y = 'World') {
    console.log(x, y);
}

log('Hello') // Hello World
log('Hello', 'China') // Hello China
log('Hello', '') // Hello

// 注意1：参数变量是默认声明的，所以不能用let或const再次声明。
// 注意2：使用参数默认值时，函数不能有同名参数。
// 注意3：定义了默认值的参数，应该是函数的尾参数
// 注意4：参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。
let x = 99;

function foo(p = x + 1) {
    console.log(p);
}

foo() // 100

x = 100;
foo() // 101

// ----------------------------可变(rest)参数-------------------------------
console.log("-----------------------------------")

function add(...values) {
    let sum = 0;
    for (let val of values) {
        sum += val;
    }
    return sum;
}

console.log(add(2, 5, 3)) // 10
// 注意：rest 参数之后不能再有其他参数（即只能是最后一个参数）

function add2(first = 0, ...values) {
    let sum = first;
    for (let val of values) {
        sum += val;
    }
    return sum;
}

console.log(add2(2, 5, 3)) // 10
```



### 3.2、返回值



| 语言       | 基本类型 | 对象/struct | 函数 | 指针 | 多个返回值 | 默认返回值 |
| ---------- | -------- | ----------- | ---- | ---- | ---------- | ---------- |
| Java       | 支持     | 支持        | --   | --   | --         | --         |
| Go         | 支持     | 支持        | 支持 | 支持 | 支持       | --         |
| Python     | --       | 支持        | 支持 | --   | --         | None       |
| JavaScript | --       | 支持        | 支持 | --   | --         | undefined  |

**说明**：Java虽然不支持返回函数，但是可以很方便返回实现单个函数的对象（Lambda）来代替函数。

Python、JavaScript的返回值不需要声明类型。

#### a、Java

```java
public class ReturnValue {
    // 返回基本数据类型、返回普通对象类型---省略

    // 模拟返回函数
    public Supplier<String> getSupplier() {
        return new Supplier<String>() {
            @Override
            public String get() {
                return "Hello World.";
            }
        };
    }

    public Supplier<String> getSupplier2() {
        return () -> "Hello skwqy";
    }

    public static void main(String[] args) {
        ReturnValue ins = new ReturnValue();
        System.out.println(ins.getSupplier().get());    // Hello World.
        System.out.println(ins.getSupplier2().get());   // Hello skwqy
    }

}
```

#### b、Go

```go
func main() {
	// 返回对象
	p := getPerson("sk", 20)
	fmt.Println(p) // {sk 20}

	// 返回指针
	ptr := getPerson2("skwqy", 20)
	fmt.Println(ptr) //&{skwqy 20}

	// 返回函数
	fun := increment()
	fmt.Printf("%T\n", fun) // func() int

	// 返回多个值
	zhouchang, area := rectangle(3, 4)
	fmt.Println(zhouchang, area) // 14 12
}

// 返回对象/struct
func getPerson(name string, age int) Person {
	return Person{name: name, age: age}
}

// 返回指针
func getPerson2(name string, age int) *Person {
	return &Person{name: name, age: age}
}

// 返回函数
func increment() func() int { // 外层函数
	// 1.定义了一个局部变量
	i := 0
	// 2.定义了一个匿名函数，给变量自增并返回
	fun := func() int {
		i++
		return i
	}
	return fun
}

// 返回多个结果
func rectangle(len, wid float64) (float64, float64) {
	peri := (len + wid) * 2
	area := len * wid
	return peri, area
}

type Person struct {
	name string
	age  int
}
```

#### c、Python

```python
# 返回对象：好像返回的是基本类型，其实返回的还是对象，Python中一切皆对象
def get_age():
    return 10

age = get_age()
print(type(age))  # <class 'int'>


def get_names():
    return ["sk", "ssk"]
print(type(get_names()))  # <class 'list'>

print("-------------返回函数-----------------")
def inc(x=0):
    def fun():
        return x + 1

    return fun


fun1 = inc()
print(type(fun1))  # <class 'function'>
i = fun1()
print(type(i))  # <class 'int'>

print("-------------默认返回值-----------------")
def get_name():
    pass
print(get_name())  # None

```

#### d、JavaScript

```javascript
// ----------------------返回对象------------------------
function getAge() {
    return 10
}

age = getAge()
console.log(age.constructor.name)     // Number
console.log(3.14.constructor.name)    // Number

function getNames() {
    return ["sk", "ssk"]
}

names = getNames()
console.log(names.constructor.name)   // Array

// ----------------------默认返回------------------------
function get_default() {

}

default1 = get_default()
console.log(default1)   // undefined

// ----------------------返回函数------------------------
function inc() {
    let i = 0
    return function fun() {
        return i++
    }
}

fun1 = inc()
console.log(fun1.constructor.name)  // Function
console.log(fun1()) // 0
console.log(fun1()) // 1

```



## 4、变量作用域与解构赋值

### 4.1、变量作用域

JavaScript全局作用域：不在任何函数内定义的变量就具有全局作用域。实际上，JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的一个属性。

ES6引入新关键字let，用let替代var可以声明一个块级作用域的变量。

| 语言       | 全局作用域 | 类作用域 | 实例作用域 | 函数作用域 | 块作用域  |      |
| ---------- | ---------- | -------- | ---------- | ---------- | --------- | ---- |
| Java       | --         | 支持     | 支持       | 支持       | 支持      |      |
| Go         | 支持       | --       | --         | 支持       | 支持      |      |
| Python     | 支持       | 支持     | 支持       | 支持       | 支持      |      |
| JavaScript | 支持       | --       | --         | 支持       | 支持(ES6) |      |

### 4.2、变量解构赋值

#### d、JavaScript

JavaScript ES6标准引入了解构赋值，可以同时对一组变量进行赋值。

解构赋值其实就是将一个序列(List、Array)按照位置和层次，Map按照key值和层次分别赋值给几个变量。

```javascript
// https://es6.ruanyifeng.com/#docs/destructuring
//--------------序列(List、Array)按位置解构---------------------
let arr = ['Hello', 'JavaScript', 'ES6']
let [x, y, z] = arr
console.log(x, y, z)  // Hello JavaScript ES6  // 全量获取
let [, yy] = arr
console.log(yy)  // JavaScript  // 按需获取

let [xxx, [, yyy]] = ['Hello', ['JavaScript', 'ES6']]
console.log(xxx, yyy)    // Hello ES6    // 按层次、按需获取

//--------------对象按key解构---------------------
console.log("----------------------------------------------")
let person = {name: '小明', age: 20, gender: 'male'}
let {name, age, father} = person
console.log(name, age, father)   // 小明 20 undefined

let person2 = {name2: '小明', age: 20, gender: 'male', address: {city: 'NanJing', zipcode: '025'}}
let {name2, address: {city}} = person2
console.log(name2, city)    // 小明 NanJing

// -------------------字符串解构赋值--------------------------
const [a, b, c, d] = 'HELLO'
console.log(a, b, c, d)    // H E L L

// -------------------数值或布尔解构赋值-----------------------------
let {toString: s} = 123
console.log(s === Number.prototype.toString)  // true
let {toString: ss} = true
console.log(ss === Boolean.prototype.toString)    // true

// ---------------------函数参数解构--------------------------
function add([x, y]) {
    return x + y;
}

console.log(add([1, 2])); // 3


// -------------------------使用场景-----------------------------
console.log("-------------------------------------------")
// 场景1：交换两个变量值
let num1 = 1, num2 = 2;
[num1, num2] = [num2, num1]
console.log(num1, num2) // 2 1

// 场景2：从函数中返回多个值
function example() {
    return [1, 2, 3];
}

let [aa, bb, cc] = example();

// 返回一个对象

function example2() {
    return {
        foo: 1,
        bar: 2
    };
}

let {foo, bar} = example2();

// 场景3：函数参数的定义
function buildDate({year, month, day, hour = 0, minute = 0, second = 0}) {
    return new Date(year + '-' + month + '-' + day + ' ' + hour + ':' + minute + ':' + second);
}

console.log(buildDate({year: 2011, month: 4, day: 23})) // 2011-04-22T16:00:00.000Z
// 场景4：提取JSON数据

// 场景5：函数参数的默认值,同函数定义中，指定了minute、second等的默认值
// 指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || 'default foo';这样的语句。

// 场景6：遍历Map结构
const map = new Map();
map.set('first', 'hello');
map.set('second', 'world');

for (let [key, value] of map) {
    console.log(key + " is " + value);
}
// 场景7：输入模块的指定方法
// const {SourceMapConsumer, SourceNode} = require("source-map");
```



## 5、匿名函数

匿名函数在Java中叫Lambda表达式，在JavaScript中叫箭头函数

### 5.1、匿名函数定义

##### a、Java

```java
public class LambdaReg {
    /*
    Lambda表达式语法：
    (参数1,参数2,...) -> {代码块}
        注意：
            1、Lambda表达式由形参列表、->、代码块组成，->用来将参数和代码块分隔开，不能省略；
            2、当只有一个参数时，小括号()可以省略；
            3、当只有一条语句时，大括号{}可以省略；代码块只有一条return语句时，可省略return关键字；
            4、Lambda表达式的目标类型必须是函数式接口（@FunctionalInterface）；函数式接口代表只能包含一个抽象方法的接口；
     */

    public static void main(String[] args) {
        // 省略return关键字, 省略大括号, 实现函数式接口：Supplier
        CompletableFuture<String> cf = CompletableFuture.supplyAsync(() -> "Hello");

        // 省略(),实现函数式接口：Function
        CompletableFuture<String> cf2 = cf.thenApply(str -> {
            System.out.println(str);
            return str + " World";
        });

        // 省略小括号、省略大括号，实现函数式接口：Consumer
        cf2.thenAccept(str -> System.out.println(str));
    }
}
```

###### a.1、Supplier：生产者

| 接口名：5       | 方法签名               | 说明 |
| --------------- | ---------------------- | ---- |
| Supplier<T>     | T get()                |      |
| BooleanSupplier | boolean getAsBoolean() |      |
| DoubleSupplier  | double getAsDouble()   |      |
| IntSupplier     | int getAsInt()         |      |
| LongSupplier    | long getAsLong()       |      |

###### a.2、Consumer：消费者

| 接口名：8            | 方法签名                       | 说明         |
| -------------------- | ------------------------------ | ------------ |
| Consumer<T>          | void accept(T t)               | 一个参数     |
| BiConsumer<T, U>     | void accept(T t, U u)          | 两个参数     |
| DoubleConsumer       | void accept(double value)      | 特例：double |
| ObjDoubleConsumer<T> | void accept(T t, double value) |              |
| IntConsumer          | void accept(int value)         | 特例：int    |
| ObjIntConsumer<T>    | void accept(T t, int value)    |              |
| LongConsumer         | void accept(long value)        | 特例：long   |
| ObjLongConsumer<T>   | void accept(T t, long value)   |              |

###### a.3、Function：消费者&生产者

| 接口名：25                                  | 方法签名                                        | 说明                       |
| ------------------------------------------- | ----------------------------------------------- | -------------------------- |
| Function<T, R>                              | R apply(T t)                                    | 一个入参一个返回值         |
| UnaryOperator<T> extends Function<T, T>     | T apply(T t)                                    | 特例：入参、返回值类型相同 |
| BiFunction<T, U, R>                         | R apply(T t, U u)                               | 两个入参一个返回值         |
| BinaryOperator<T> extends BiFunction<T,T,T> | T apply(T t, T u)                               | 特例：三个参数类型相同     |
| DoubleFunction<R>                           | R apply(double value)                           | 特例：输入参数为double     |
| DoubleToIntFunction                         | int applyAsInt(double value)                    |                            |
| DoubleToLongFunction                        | long applyAsLong(double value)                  |                            |
| DoubleUnaryOperator                         | double applyAsDouble(double operand)            |                            |
| DoubleBinaryOperator                        | double applyAsDouble(double left, double right) |                            |
| IntFunction<R>                              | R apply(int value)                              | 特例：输入参数为int        |
| IntUnaryOperator                            | int applyAsInt(int operand)                     |                            |
| IntToLongFunction                           | long applyAsLong(int value)                     |                            |
| IntToDoubleFunction                         | double applyAsDouble(int value)                 |                            |
| IntBinaryOperator                           | int applyAsInt(int left, int right)             |                            |
| LongFunction<R>                             | R apply(long value)                             | 特例：输入参数为long       |
| LongToIntFunction                           | int applyAsInt(long value)                      |                            |
| LongUnaryOperator                           | long applyAsLong(long operand)                  |                            |
| LongToDoubleFunction                        | double applyAsDouble(long value)                |                            |
| LongBinaryOperator                          | long applyAsLong(long left, long right)         |                            |
| ToDoubleFunction<T>                         | double applyAsDouble(T value)                   | 特例：返回参数为double     |
| ToDoubleBiFunction<T, U>                    | double applyAsDouble(T t, U u)                  |                            |
| ToIntFunction<T>                            | int applyAsInt(T value)                         | 特例：返回参数为int        |
| ToIntBiFunction<T, U>                       | int applyAsInt(T t, U u)                        |                            |
| ToLongFunction<T>                           | long applyAsLong(T value)                       | 特例：返回参数为long       |
| ToLongBiFunction<T, U>                      | long applyAsLong(T t, U u)                      |                            |

###### a.4、Predicate：谓词

| 接口：5           | 方法签名                   | 说明         |
| ----------------- | -------------------------- | ------------ |
| Predicate<T>      | boolean test(T t)          | 一个入参     |
| BiPredicate<T, U> | boolean test(T t, U u)     | 二个入参     |
| DoublePredicate   | boolean test(double value) | 特例：double |
| IntPredicate      | boolean test(int value)    | 特例：int    |
| LongPredicate     | boolean test(long value)   | 特例：long   |

##### b、Go

```go
func main() {
	// 将匿名函数赋值给变量
	func4 := func(a, b int) int {
		return a + b
	}
	fmt.Printf("%T\n", func4) //func(int, int) int
	res1 := func4(10, 100)
	fmt.Println(res1) // 110

	// 函数调用时，直接定义匿名函数
	res3 := oper(200, 300, func(a int, b int) int {
		return a + b
	})
	fmt.Println(res3) // 500
}

// 和Python、JavaScript一样，可以直接将函数作为普通参数，但是却能看到函数声明，代码阅读起来比Python、JavaScript清洗
func oper(a, b int, fun func(int, int) int) int {
	return fun(a, b)
}
```

##### c、Python

```python
# coding:utf-8
"""
匿名函数语法：
    lambda [arg1 [,arg2, ... argN]] : expression
    注意：
        1、匿名函数由 关键字lambda、形参列表、冒号(:)、表达式 四部分组成；形参如果没有可以省略；
        2、冒号(:)是形参和表达式的分隔符
"""

def build(x, y):
    return lambda: x * x + y * y

lambda1 = build(2, 3)
print(type(lambda1))    # <class 'function'>
print(lambda1())    # 13
```

##### d、JavaScript

```javascript
/*
 Lambda表达式语法：
    (参数1,参数2,...) => {代码块}
        注意：
            1、Lambda表达式由 形参列表、=>、代码块组成，=>用来将参数和代码块分隔开，不能省略；
            2、当只有一个参数时，小括号()可以省略；
            3、当只有一条语句时，大括号{}可以省略；代码块只有一条return语句时，可省略return关键字；
 */

let fn = x => x * x
console.log(fn.constructor.name)    // Function
console.log(fn(2))  // 4
```

## 6、闭包

## 7、高阶函数

高阶函数：如果一个函数的参数可以接受另一个函数作为参数，那么这种函数就称之为高阶函数。

### 7.1、高阶函数应用

#### 7.1.1、Java

##### a、Stream

a.1、流创建

```java
Stream<Integer> stream = List.of(1, 2, 3).stream();
Stream<String> stream1 = new HashSet<String>().stream();
IntStream stream2 = Arrays.stream(new int[]{1, 2, 3});
Map<String, String> map = new HashMap<>();
Stream<String> stream3 = map.keySet().stream();
Stream<String> stream4 = map.values().stream();
```

a.2、中间操作

| 操作                                    | 说明                                                         |
| --------------------------------------- | ------------------------------------------------------------ |
| Stream filter(Predicate)                | 对流中的元素进行过滤                                         |
| Stream map(Function)                    | 对流中的元素进行映射                                         |
| Stream peek(Consumer)                   | 用作debug，peek中操作并不会影响流中的元素，它的参数是Consumer，没有返回。 |
| Stream flatMap(Function)                | 对流中的元素进行扁平化，扁平化之前，流中元素可能是数组       |
| Stream limit(long)                      | 截取指定个数的流                                             |
| Stream skip(long)                       | 跳过指定个数的的流                                           |
| Stream distinct()                       | 元素去重，根据元素的equals方法进行去重                       |
| static Stream concat(Stream a,Stream b) | 合并a、b两个流为一个流                                       |
| Stream<T> sorted()                      | 将流中的元素进行排序                                         |
| Stream<T> dropWhile(Predicate)          | 从流中删除满足条件的元素，直到遇到第一个不满足条件的终止。JDK9新增 |
| Stream<T> takeWhile(Predicate)          | 从流中获取满足条件的元素，直到遇到第一个不满足条件时终止。JDK9新增 |

a.3、终结操作

| 操作                          | 说明                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| void forEach(Consumer)        | 对流中的每个元素执行指定操作，执行顺序不确定，有助于并行操作中提升性能 |
| void forEachOrdered(Consumer) | 对流中的每个元素执行指定操作，按照流中元素顺序执行。         |
| T reduce(BinaryOperator）     | 对流中的元素进行计算，最终生成一个值。count、min、max都是reduce的一种计算方式。 |
| long count()                  | 返回流中元素个数                                             |
| T max(Comparator)             | 返回流中最大的元素                                           |
| T min(Comparator)             | 返回流中最小的元素                                           |
| R collect(Collector)          | 把结果收集到集合中                                           |
| List<T> toList()              | 把结果收集到List中                                           |
| Object[] toArray()            | 把结果收集到数组中                                           |
| boolean allMatch(Predicate)   | 流中的元素是否全部匹配谓词Predicate                          |
| boolean anyMatch(Predicate)   | 流中的元素是否有匹配谓词Predicate                            |
| boolean noneMatch(Predicate)  | 流中元素是否都未匹配谓词                                     |
| Optional<T> findAny()         | 选择流中的任何元素，该方法行为是不确定的，该方法有助于在并行操作中获得最大性能 |
| Optional<T> findFirst()       | 选择第一个元素                                               |



##### b、CompletableFuture

已经有为Future什么还需要CompletableFuture？

1. Future的结果在非阻塞的情况下，不能执行更进一步的操作。

   使用Future时只能通过isDone()方法判断任务是否完成，或者通过get()方法阻塞线程等待结果返回，它不能在非阻塞的情况下，执行更进一步的操作。

2. 不能组合多个Future的结果。

   假设你有多个Future异步任务，你希望最快的任务完成时，或者所有任务都执行完后，进行一些其它处理。

3. 多个Future不能组合成链式调用。

   当异步任务之间有依赖关系时，Future不能将一个任务的结果传递给另一个异步任务，多个Future无法创建链式的工作流。

4. 没有异常处理。

```java
// https://zhuanlan.zhihu.com/p/344431341
// 模板三件套
CompletableFuture<Void> thenAccept(Consumer);	//同步操作
CompletableFuture<Void> thenAcceptAsync(Consumer);	// 异步操作，使用默认线程池
CompletableFuture<Void> thenAcceptAsync(Consumer,Executor);	// 异步操作，使用自定义线程池
// 后续都以 thenAcceptAsync(Consumer) 这种形式为例
```

b.1、实例化CompletableFuture

| 方法                                                       | 说明                                     |
| ---------------------------------------------------------- | ---------------------------------------- |
| static CompletableFuture<U> supplyAsync(Supplier)          | 可以返回异步线程执行之后的结果。         |
| static CompletableFuture<U> supplyAsync(Supplier,Executor) | 同上，并使用自定义的线程池进行异步执行。 |
| static CompletableFuture<Void> runAsync(Runnable)          | 只是异步执行线程任务。                   |
| static CompletableFuture<Void> runAsync(Runnable,Executor) | 同上，使用自定义的线程池执行异步任务。   |

b.2、同步获取结果

| 方法                      | 说明                                                         |
| ------------------------- | ------------------------------------------------------------ |
| T get()                   | 获取任务结果，阻塞直到任务完成                               |
| T get(long, TimeUnit)     | 同步获取任务结果，设置对应的超时时间。                       |
| T getNow(T valueIfAbsent) | 获取任务结果，如果计算结果不存在或Now时刻没有完成任务，则给定一个默认值。 |
| T join()                  | join()与get()的区别在于join返回计算的结果或抛出一个unchecked异常，而get返回一个具体的异常。 |

b.3、计算完成后操作（CompletableFuture 简写为CF）

| 方法                                           | 说明                                                   |
| ---------------------------------------------- | ------------------------------------------------------ |
| CF<T> whenComplete(BiConsumer<T, Throwable>)   | 能处理异常和返回结果（结果类型无法自定义）。三件套     |
| CF<U> handle(BiFunction<T, Throwable, U>)      | 能处理异常和返回结果（结果类型能自定义）。三件套       |
| CF<U> thenApplyAsync(Function<T, U>            | 无法处理异常，但能返回结果（结果类型可自定义）。三件套 |
| CF<Void> thenAcceptAsync(Consumer<T>)          | 只能作最终结果的消费，类似流的终端操作。三件套         |
| CF<T> exceptionally(Function<Throwable, T> fn) | 专门处理异常，且必须return一个返回值。                 |

b.4、组合

| 方法                                                      | 说明                                                         |
| --------------------------------------------------------- | ------------------------------------------------------------ |
| CF<U> thenApplyAsync(Function<T, U>                       | 将两个异步计算合并为一个，两个异步计算相互独立，第二依赖第一个结果。三件套 |
| CF<U> thenCompose(Function<T, CF<U>> fn)                  | 将两个异步计算合并为一个，两个异步计算相互独立，互不依赖。三件套 |
| CF<V> thenCombineAsync(CS<U> other, BiFunction<T,U,V> fn) | 将两个异步计算合并为一个，两个异步计算相互独立，互不依赖。三件套 |
| CF<Void> allOf(CF<?>... cfs)                              | 等待Feture集合中的所有任务都完成。                           |
| CF<Object> anyOf(CF<?>... cfs)                            | 仅等待Feture集合中最快结束的任务完成，并发挥它的结果。       |



#### 7.1.2、Go

```go

```

#### 7.1.3、Python

```python

```

#### 7.1.4、JavaScript

##### a、map/reduce

```javascript
//--------------------map---------------------------
function pow(x) {
    return x * x
}

let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]
let res = arr.map(pow)
console.log(res)    //[1,  4,  9, 16, 25, 36, 49, 64, 81]

// ---------------------reduce-----------------------------
function add(x, y) {
    return x + y
}

res2 = arr.reduce(add)
// [x1, x2, x3, x4].reduce(f) = f(f(f(x1,x2),x3),x4)
console.log(res2)  // 45

// ------------------------使用场景简介-------------------------
// 将[1,3,5,7,9]变成13579
let arr2 = [1, 3, 5, 7, 9]
res3 = arr2.reduce(function (x, y) {
    return x * 10 + y
})
console.log(res3)   // 13579
res31 = arr2.reduce((x, y) => 10 * x + y)
console.log(res31)   // 13579

// ['1','2','3'] 字符串变整数
let arr4 = ['1', '2', '3']
res4 = arr4.map(parseInt)
console.log(res4)   // [ 1, NaN, NaN ]

res41 = arr4.map((x) => parseInt(x))
console.log(res41)  // [ 1, 2, 3 ]
```

##### b、forEach、filter

```javascript
let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

// 遍历：无返回值
arr.forEach(x => console.log(x))

// 过滤：返回true保留、返回false丢弃
res = arr.filter(x => x % 2 === 0)
console.log(res)  // [ 2, 4, 6, 8, 10 ]
```

##### c、sort

```javascript
let arr = [2, 1, 9, 6, 4, 8, 5, 3, 7]

let res1 = arr.sort((a, b) => {
    if (a > b) {
        return 1
    } else if (a < b) {
        return -1
    } else {
        return 0
    }
})
console.log(res1)   // [1,2,3,4,5,6,7,8,9]

let res2 = arr.sort((a, b) => {
    if (a > b) {
        return -1
    } else if (a < b) {
        return 1
    } else {
        return 0
    }
})
console.log(res2)   // [9,8,7,6,5,4,3,2,1]
```

##### d、Array

```javascript
// Array还有一些其它的高阶函数
// -------------------every-----------------------
let arr = ['Apple', 'pear', 'orange']
// 判断是否每个元素的length都大于0
let isNotEmpty = arr.every(x => x.length > 0)
console.log(isNotEmpty) // true

// -------------------find----------------------
// 找到符合条件的第一个元素
let firstLowerWorld = arr.find(x => x.toLowerCase() === x)
console.log(firstLowerWorld)    // pear

// -------------------findIndex-----------------------
let firstLowerWorldIdx = arr.findIndex(x => x.toLowerCase() === x)
console.log(firstLowerWorldIdx) // 1
```



7.2、

## 8、递归函数

## 9、生成器(generator)

# 三、面向对象

面向对象的特点：封装、继承、多态

## 1、封装

**封装的目的**：隐藏程序的具体实现细节；让使用者看到刚刚好的数据和行为（接口）

**封装的含义**：

- 属性和行为捆绑：把对象的属性和行为看成一个密不可分的整体，将这两者“封装”在一个不可分割的独立单元（类、对象）中；
- 信息隐藏：把不需要外界知道的信息隐藏起来，有些对象的属性及行为允许外界用户知道或使用，但不允许更改；另外一些属性或行为，则不允许外界知晓，只允许使用对象的功能，而尽可能隐藏对象的功能实现细节。

**封装的优点**：

- 良好的封装能够减少耦合，符合程序设计追求的“高内聚，低耦合”。
- 能够自由的控制被隐藏的属性和行为，这些操作对使用者都是透明的。

**封装手段**：

- 接口：提供给使用者；没有甚至很要包含具体的实现细节；
- 类：具体的实现；包含所有的实现细节；包含并控制数据和行为；
- 对象：捆绑了自己实例的数据和类模板的行为，将其融为一体，对外提供真正的服务

## 2、继承

**继承的目的**：代码复用

**继承的特点**：

- 继承可以获得父类的某些属性和行为；
- 可以选择覆盖（重写）父类的行为；
- 可以添加自己特有的属性和行为；



## 3、多态

**多态的目的**：提升了编程的灵活性，简化使用者使用，使用者不比关注谁来提供服务（具体实现），只用关注能使用声明服务（接口）

多态发送在运行运行期间，即类型多态，不同类型的对象实体具有统一接口，相同的消息给予不同的对象会引发不同的动作。

| 语言       | 面向对象手段                        | 优点         | 缺点                                                         |
| ---------- | ----------------------------------- | ------------ | ------------------------------------------------------------ |
| Java       | Interface、Class、implement、extend | 都是优点     | 侵入式接口                                                   |
| Go         | interface、struct、method           | 非侵入式接口 | 封装不足，需要通过Interface、struct组合模拟；继承不足，需要通过struct成员模拟； |
| Python     | Class、extend()                     |              |                                                              |
| JavaScript | class、extends、prototype(实际)     |              |                                                              |

## 4、面向对象原理

### 4.4、JavaScript继承原理

图解JS原型链： https://blog.csdn.net/cc18868876837/article/details/81211729

new 操作符原理解析： https://blog.csdn.net/cc18868876837/article/details/103149502

原型链继承实现： https://www.liaoxuefeng.com/wiki/1022910821149312/1023021997355072

- **new操作符原理**

  new关键字进行了如下的操作（为了便于描述，obj用来表示创建的空对象、用constrc来表示构造函数）：

  1. 创建一个空对象obj（{}）；
  2. 将obj的[[prototype]]属性指向构造函数constrc的原型（即obj.[[prototype]] = constrc.prototype）。
  3. 将构造函数constrc内部的this绑定到新建的对象obj，执行constrc（也就是跟调用普通函数一样，只是此时函数的this为新创建的对象obj而已，就好像执行obj.constrc()一样）；
  4. 若构造函数没有返回非原始值（即不是引用类型的值），则返回该新建的对象obj（默认会添加return this）。否则，返回引用类型的值。

  这里补充说明一下：[[prototype]]属性是隐藏的，不过目前大部分新浏览器实现方式是使用__ proto __来表示。构造函数的prototype属性我们是可以显式访问的。

- **搞懂prototype、__ proto __(ES中[[Prototype]])与constructor**

  1. 我们需要牢记两点：① __ proto __ 和constructor属性是对象所独有的；② prototype属性是函数所独有的，因为函数也是一种对象，所以函数也拥有__ proto __和constructor属性。
  2. __ proto __ 属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的__ proto __ 属性所指向的那个对象（父对象）里找，一直找，直到 __ proto __ 属性的终点null，再往上找就相当于在null上取值，会报错。通过__ proto __属性将对象连接起来的这条链路即我们所谓的原型链。
  3. prototype属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即f1. __ proto __ === Foo.prototype。**任何函数在创建的时候，其实会默认同时创建该函数的prototype对象。**
  4. constructor属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向Function。

  ```javascript
  function Foo(){}
  let f1 = new Foo()
  ```

  ![原型链](./image/js/原型链.png)

- **模拟继承**

  模拟PrimaryStudent继承Student

  ```javascript
  function Student(props) {
      this.name = props.name || 'Unnamed';
  }
  
  function PrimaryStudent(props) {
      // 调用Student构造函数，绑定this变量:
      Student.call(this, props);
      this.grade = props.grade || 1;
  }
  
  // 但是，调用了Student构造函数不等于继承了Student，PrimaryStudent创建的对象的原型是：
  // new PrimaryStudent() -> PrimaryStudent.prototype -> Object.prototype -> null
  // 必须想办法把原型链修改为：
  // new PrimaryStudent() -> PrimaryStudent.prototype -> Student.prototype -> Object.prototype -> null
  
  // 我们必须借助一个中间对象来实现正确的原型链，这个中间对象的原型要指向Student.prototype。为了实现这一点，参考道爷（就是发明JSON的那个道格拉斯）的代码，中间对象可以用一个空函数F来实现：
  
  // PrimaryStudent构造函数:
  function PrimaryStudent(props) {
      Student.call(this, props);
      this.grade = props.grade || 1;
  }
  
  // 空函数F:
  function F() {
  }
  
  // 把F的原型指向Student.prototype:
  F.prototype = Student.prototype;
  
  // 把PrimaryStudent的原型指向一个新的F对象，F对象的原型正好指向Student.prototype:
  PrimaryStudent.prototype = new F();
  
  // 把PrimaryStudent原型的构造函数修复为PrimaryStudent:
  PrimaryStudent.prototype.constructor = PrimaryStudent;
  
  // 继续在PrimaryStudent原型（就是new F()对象）上定义方法：
  PrimaryStudent.prototype.getGrade = function () {
      return this.grade;
  };
  
  // 创建xiaoming:
  var xiaoming = new PrimaryStudent({
      name: '小明',
      grade: 2
  });
  xiaoming.name; // '小明'
  xiaoming.grade; // 2
  
  // 验证原型:
  xiaoming.__proto__ === PrimaryStudent.prototype; // true
  xiaoming.__proto__.__proto__ === Student.prototype; // true
  
  // 验证继承关系:
  xiaoming instanceof PrimaryStudent; // true
  xiaoming instanceof Student; // true
  ```

  ![模拟继承原型链](./image/js/模拟继承原型链.png)

  ```javascript
  // 模拟继承的通用函数
  function inherits(Child, Parent) {
      var F = function () {};
      F.prototype = Parent.prototype;
      Child.prototype = new F();
      Child.prototype.constructor = Child;
  }
  ```

  

## 5、面向对象实践

### a、Java

```java
public class Oop {
    public static interface IPerson {
        void eat();

        void study();
    }

    public static class Person implements IPerson {
        protected final String name;
        private final int age;

        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }

        @Override
        public void eat() {
            System.out.println("Person....eat....");
        }

        @Override
        public void study() {
            System.out.println("Person....study....");
        }
    }

    public static class Student extends Person {
        private final String school;

        public Student(String name, int age, String school) {
            super(name, age);
            this.school = school;
        }

        @Override
        public void study() {
            System.out.println("Strudent(" + name + ")....study....in " + school);
        }
    }

    public static void main(String[] args) {
        IPerson person = new Person("王二狗", 30);
        person.eat();   // Person....eat....
        person.study(); // Person....study....
        person = new Student("张小花", 20, "银城小学");
        person.eat();   // Person....eat....   // 继承父类的
        person.study(); // Strudent(张小花)....study....in 银城小学  // 覆盖父类的
    }
}
```

### b、Go

```go
func main() {
	/*
		OOP中的继承性：
			如果两个类(class)存在继承关系，其中一个是子类，另一个作为父类，那么：
			1.子类可以直接访问父类的属性和方法
			2.子类可以新增自己的属性和方法
			3.子类可以重写父类的方法(orverride，就是将父类已有的方法，重新实现)
		Go语言的结构体嵌套：
			1.模拟继承性：is - a
				type A struct{
					field
				}
				type B struct{
					A //匿名字段
				}
			2.模拟聚合关系：has - a
				type C struct{
					field
				}
				type D struct{
					c C //聚合关系
				}
	*/
	//1.创建Person类型
	var p1 IPerson = Person{name: "王二狗", age: 30}
	p1.eat()   // 父类的方法，吃窝窝头。。
	p1.study() // 父类的方法，学生学习啦。。。

	//2.创建Student类型
	var s1 IPerson = Student{Person{"Ruby", 18}, "千锋教育"}

	s1.eat()   //子类重写的方法：吃炸鸡喝啤酒。。 // 此时子类没有该方法时，就访问匿名字段的
	s1.study() //子类重写的方法，学生学习啦。。。
}

//1.定义一个"父类"
type Person struct {
	name string
	age  int
}

//2.定义一个"子类"
type Student struct {
	Person //结构体嵌套，模拟继承性
	school string
}

//3.方法
func (p Person) eat() {
	fmt.Println("父类的方法，吃窝窝头。。")
}
func (p Person) study() {
	fmt.Println("父类的方法，学生学习啦。。。")
}

func (s Student) study() {
	fmt.Println("子类重写的方法，学生学习啦。。。")
}

func (s Student) eat() {
	fmt.Println("子类重写的方法：吃炸鸡喝啤酒。。")
}

type IPerson interface {
	eat()
	study()
}
```

### c、Python

```python
# coding:utf-8

class Person:
    # 构造方法
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def eat(self):
        print("Person(", self.name, ")....eat.....")

    def study(self):
        print("Person.....study.......")


class Student(Person):

    def eat(self):
        print("Student(", self.name, ")....eat.....")

    def study(self):
        print("Student.....study.......")


person = Person("sk", 30)
person.eat()  # Person( sk )....eat.....
person.study()  # Person.....study.......

student = Student("skwqy", 30)
student.eat()  # Student( skwqy )....eat.....
student.study()  # Student.....study.......
```

### d、JavaScript

```javascript
class Person {
    // 构造函数
    constructor(name, age) {
        this.name = name
        this.age = age
    }

    // 成员方法，定义时不需要关键字function
    eat() {
        console.log("Person(", this.name, ") .....eat......")
    }

    study() {
        console.log("Person(", this.name, ") .....study......")
    }
}

class Student extends Person {
    eat() {
        console.log("Student(", this.name, ") .....eat......")
    }

    study() {
        console.log("Student(", this.name, ") .....study......")
    }
}

let person = new Person("sk", 30)
person.eat()    // Person( sk ) .....eat......
person.study()  // Person( sk ) .....study......

let student = new Student("skwqy", 29)
student.eat()   // Student( skwqy ) .....eat......
student.study() // Student( skwqy ) .....study......
```



# 反射

# 四、并发编程

## 1、并发性Concurrency

### 1.1、多任务

怎么来理解多任务呢？其实就是指我们的操作系统可以同时执行多个任务。举个例子，你一边听音乐，一边刷微博，一边聊QQ，一边用Markdown写作业，这就是多任务，至少同时有4个任务正在运行。还有很多任务悄悄地在后台同时运行着，只是界面上没有显示而已。

### 1.2、什么是并发

**并发性Concurrency是同时处理许多事情的能力。**

举个例子，假设一个人在晨跑。在晨跑时，他的鞋带松了。现在这个人停止跑步，系鞋带，然后又开始跑步。这是一个典型的并发性示例。这个人能够同时处理跑步和系鞋带，这是一个人能够同时处理很多事情。

什么是并行性parallelism，它与并发concurrency有什么不同?
并行就是同时做很多事情。这听起来可能与并发类似，但实际上是不同的。

让我们用同样的慢跑例子更好地理解它。在这种情况下，我们假设这个人正在慢跑，并且使用它的手机听音乐。在这种情况下，一个人一边慢跑一边听音乐，那就是他同时在做很多事情。这就是所谓的并行性(parallelism)。

并发性和并行性——一种技术上的观点。
假设我们正在编写一个web浏览器。web浏览器有各种组件。其中两个是web页面呈现区域和下载文件从internet下载的下载器。假设我们以这样的方式构建了浏览器的代码，这样每个组件都可以独立地执行。当这个浏览器运行在单个核处理器中时，处理器将在浏览器的两个组件之间进行上下文切换。它可能会下载一个文件一段时间，然后它可能会切换到呈现用户请求的网页的html。这就是所谓的并发性。并发进程从不同的时间点开始，它们的执行周期重叠。在这种情况下，下载和呈现从不同的时间点开始，它们的执行重叠。

假设同一浏览器运行在多核处理器上。在这种情况下，文件下载组件和HTML呈现组件可能同时在不同的内核中运行。这就是所谓的并行性。

![并发与并行](./image/common/并发与并行.png)

并行性Parallelism不会总是导致更快的执行时间。这是因为并行运行的组件可能需要相互通信。例如，在我们的浏览器中，当文件下载完成时，应该将其传递给用户，比如使用弹出窗口。这种通信发生在负责下载的组件和负责呈现用户界面的组件之间。这种通信开销在并发concurrent 系统中很低。当组件在多个内核中并行concurrent 运行时，这种通信开销很高。因此，并行程序并不总是导致更快的执行时间!

![串行并行并发](./image/common/串行并行并发.png)

### 1.3、进程、线程、协程

**进程(Process)，线程(Thread)，协程(Coroutine，也叫轻量级线程)**

**进程**
进程是一个程序在一个数据集中的一次动态执行过程，可以简单理解为“正在执行的程序”，它是CPU资源分配和调度的独立单位。 
进程一般由程序、数据集、进程控制块三部分组成。我们编写的程序用来描述进程要完成哪些功能以及如何完成；数据集则是程序在执行过程中所需要使用的资源；进程控制块用来记录进程的外部特征，描述进程的执行变化过程，系统可以利用它来控制和管理进程，它是系统感知进程存在的唯一标志。 **进程的局限是创建、撤销和切换的开销比较大。**

进程申请的资源包含如下：

- 已打开的文件
- 已申请到的I/O设备
- 用户的地址空间
- 进程维护的地址映射表
- 实现进程（线程）间同步和通信的机制

**线程**
线程是在进程之后发展出来的概念。 线程也叫轻量级进程，它是一个基本的CPU执行单元，也是程序执行过程中的最小单元，由线程ID、程序计数器、寄存器集合和堆栈共同组成。一个进程可以包含多个线程。 
线程的**优点**是减小了程序并发执行时的开销，提高了操作系统的并发性能，**缺点**是线程没有自己的系统资源，只拥有在运行时必不可少的资源，但同一进程的各线程可以共享进程所拥有的系统资源，如果把进程比作一个车间，那么线程就好比是车间里面的工人。不过对于某些独占性资源存在锁机制，处理不当可能会产生“死锁”。

**协程**
协程是一种用户态的轻量级线程，又称微线程，英文名Coroutine，协程的调度完全由用户控制。人们通常将协程和子程序（函数）比较着理解。 
子程序调用总是一个入口，一次返回，一旦退出即完成了子程序的执行。 

**与传统的系统级线程和进程相比，协程的最大优势在于其"轻量级"，可以轻松创建上百万个而不会导致系统资源衰竭，而线程和进程通常最多也不能超过1万的。这也是协程也叫轻量级线程的原因。**

> 协程与多线程相比，其优势体现在：协程的执行效率极高。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。

**线程**的出现，是为了分离进程的两个功能：资源分配和系统调度。让更细粒度、更轻量的线程来承担调度，减轻调度带来的开销。但线程还是不够轻量，因为调度是在内核空间进行的，每次线程切换都需要陷入内核，这个开销还是不可忽视的。

**协程**则是把调度逻辑在用户空间里实现，通过自己（编译器运行时系统/程序员）模拟控制权的交接，来达到更加细粒度的控制。

## 2、并发模型

### 2.1、多进程模型

主进程监听和管理连接，当有客户请求的时候，fork 一个子进程来处理连接，父进程继续等待其他客户的请求。但是进程占用服务器资源是比较多的，服务器负载会很高。
Apache的web容器实现就是这种模型

### 2.2、多线程与锁

几乎每种编程语言都以某种形式提供了支持，我们应该了解底层的原理，但是，多数时候，应该使用更上层的类库，更高效，更不易出错。这种方式无外乎几种经典的模式，互斥锁（临界区），生产者-消费者，同步等等

优点：

- 好理解 基础语言库都有支持，容易实现
- 其他并发模型的基础

缺点：

- 难以测试，很容易隐藏某些难以发现的问题
- 会频繁地创建、销毁线程。这对系统也是个不小的开销

### 2.3、单线程回调和事件轮询模型

**Nginx**
采用的是多进程（单线程） & 多路IO复用模型:
Nginx 在启动后，会有一个 master 进程和多个相互独立的 worker 进程。
接收来自外界的信号，向各 worker 进程发送信号，每个进程都有可能来处理这个连接
master 进程能监控 worker 进程的运行状态，当 worker 进程退出后(异常情况下)，会自动启动新的 worker 进程。
主进程（master 进程）首先通过 socket() 来创建一个 sock 文件描述符用来监听，然后fork生成子进程（workers 进程），子进程将继承父进程的 sockfd（socket 文件描述符），之后子进程 accept() 后将创建已连接描述符（connected descriptor）），然后通过已连接描述符来与客户端通信。
**缺点**
存在惊群现象：当连接进来时，所有子进程都将收到通知并“争着”与它建立连接。
Nginx 在 accept 上加一把互斥锁来应对惊群现象。在每个 worker 进程里，Nginx 调用内核 epoll()函数来实现 I/O 的多路复用。

**Node.js**
Node.js 也是单线程模型。Node.js中所有的逻辑都是事件的回调函数，所以 Node.js始终在事件循环中，程序入口就是事件循环第一个事件的回调函数。

**缺点**
会造成大量回调函数的嵌套，代码可读性不佳。因为没有多线程，在多核的机器上，也没办法实现并行执行。

### 2.4、协程模型

协程基于用户空间的调度器，具体的调度算法由具体的编译器和开发者实现，相比多线程和事件回调的方式，更加灵活可控。不同语言协程的调度方式也不一样，python是在代码里显式地yield进行切换，golang 则是用go语法来开启 goroutine，具体的调度由语言层面提供的运行时执行。

在使用 goroutine 的时候，可以把它当作轻量级的线程来用，和多进程、多线程方式一样，主 goroutine 监听，开启多个工作 goroutine 处理连接。比起多线程的方式，优势在于能开更多的 goroutine，来处理连接

**G-P-M 模型理解**

> 在操作系统提供的内核线程之上，Go搭建了一个特有的两级线程模型。goroutine机制实现了M : N的线程模型，goroutine机制是协程（coroutine）的一种实现，golang内置的调度器，可以让多核CPU中每个CPU执行一个协程。
>
> #### 1 调度器是如何工作的
>
> 有了上面的认识，我们可以开始真正的介绍Go的并发机制了，先用一段代码展示一下在Go语言中新建一个“线程”(Go语言中称为Goroutine)的样子：
>
> ```go
> // 用go关键字加上一个函数（这里用了匿名函数）
> // 调用就做到了在一个新的“线程”并发执行任务
> go func() { 
>     // do something in one new goroutine
> }()
> ```
>
> 功能上等价于Java8的代码:
>
> ```java
> new java.lang.Thread(() -> { 
>     // do something in one new thread
> }).start();
> ```
>
> 理解goroutine机制的原理，关键是理解Go语言scheduler的实现。
>
> Go语言中支撑整个scheduler实现的主要有4个重要结构，分别是M、G、P、Sched， 前三个定义在runtime.h中，Sched定义在proc.c中。
>
> - Sched结构就是调度器，它维护有存储M和G的队列以及调度器的一些状态信息等。
> - M结构是Machine，系统线程，它由操作系统管理的，goroutine就是跑在M之上的；M是一个很大的结构，里面维护小对象内存cache（mcache）、当前执行的goroutine、随机数发生器等等非常多的信息。
> - P结构是Processor，处理器，它的主要用途就是用来执行goroutine的，它维护了一个goroutine队列，即runqueue。Processor是让我们从N:1调度到M:N调度的重要部分。
> - G是goroutine实现的核心结构，它包含了栈，指令指针，以及其他对调度goroutine很重要的信息，例如其阻塞的channel。
>
> > Processor的数量是在启动时被设置为环境变量GOMAXPROCS的值，或者通过运行时调用函数GOMAXPROCS()进行设置。Processor数量固定意味着任意时刻只有GOMAXPROCS个线程在运行go代码。
>
> 我们分别用三角形，矩形和圆形表示Machine Processor和Goroutine。
>
> ![moxing4](./image/common/moxing4.jpg)
>
> 在单核处理器的场景下，所有goroutine运行在同一个M系统线程中，每一个M系统线程维护一个Processor，任何时刻，一个Processor中只有一个goroutine，其他goroutine在runqueue中等待。一个goroutine运行完自己的时间片后，让出上下文，回到runqueue中。 多核处理器的场景下，为了运行goroutines，每个M系统线程会持有一个Processor。
>
> ![moxing5](./image/common/moxing5.jpg)
>
> 在正常情况下，scheduler会按照上面的流程进行调度，但是线程会发生阻塞等情况，看一下goroutine对线程阻塞等的处理。
>
> #### 2 线程阻塞
>
> 当正在运行的goroutine阻塞的时候，例如进行系统调用，会再创建一个系统线程（M1），当前的M线程放弃了它的Processor，P转到新的线程中去运行。
>
> ![moxing6](./image/common/moxing6.jpg)
>
> #### 3 runqueue执行完成
>
> 当其中一个Processor的runqueue为空，没有goroutine可以调度。它会从另外一个上下文偷取一半的goroutine。
>
> ![moxing7](./image/common/moxing7.jpg)
>
> > 其图中的G，P和M都是Go语言运行时系统（其中包括内存分配器，并发调度器，垃圾收集器等组件，可以想象为Java中的JVM）抽象出来概念和数据结构对象：
> > G：Goroutine的简称，上面用go关键字加函数调用的代码就是创建了一个G对象，是对一个要并发执行的任务的封装，也可以称作用户态线程。属于用户级资源，对OS透明，具备轻量级，可以大量创建，上下文切换成本低等特点。
> > M：Machine的简称，在linux平台上是用clone系统调用创建的，其与用linux pthread库创建出来的线程本质上是一样的，都是利用系统调用创建出来的OS线程实体。M的作用就是执行G中包装的并发任务。**Go运行时系统中的调度器的主要职责就是将G公平合理的安排到多个M上去执行**。其属于OS资源，可创建的数量上也受限了OS，通常情况下G的数量都多于活跃的M的。
> > P：Processor的简称，逻辑处理器，主要作用是管理G对象（每个P都有一个G队列），并为G在M上的运行提供本地化资源。
>
> 从两级线程模型来看，似乎并不需要P的参与，有G和M就可以了，那为什么要加入P这个东东呢？
> 其实Go语言运行时系统早期(Go1.0)的实现中并没有P的概念，Go中的调度器直接将G分配到合适的M上运行。但这样带来了很多问题，例如，不同的G在不同的M上并发运行时可能都需向系统申请资源（如堆内存），由于资源是全局的，将会由于资源竞争造成很多系统性能损耗，为了解决类似的问题，后面的Go（Go1.1）运行时系统加入了P，让P去管理G对象，M要想运行G必须先与一个P绑定，然后才能运行该P管理的G。这样带来的好处是，我们可以在P对象中预先申请一些系统资源（本地资源），G需要的时候先向自己的本地P申请（无需锁保护），如果不够用或没有再向全局申请，而且从全局拿的时候会多拿一部分，以供后面高效的使用。就像现在我们去政府办事情一样，先去本地政府看能搞定不，如果搞不定再去中央，从而提供办事效率。
> 而且由于P解耦了G和M对象，这样即使M由于被其上正在运行的G阻塞住，其余与该M关联的G也可以随着P一起迁移到别的活跃的M上继续运行，从而让G总能及时找到M并运行自己，从而提高系统的并发能力。
> Go运行时系统通过构造G-P-M对象模型实现了一套用户态的并发调度系统，可以自己管理和调度自己的并发任务，所以可以说Go语言**原生支持并发**。**自己实现的调度器负责将并发任务分配到不同的内核线程上运行，然后内核调度器接管内核线程在CPU上的执行与调度。**
>
> 可以看到Go的并发用起来非常简单，用了一个语法糖将内部复杂的实现结结实实的包装了起来。其内部可以用下面这张图来概述：
>
> ![goroutine2](./image/common/goroutine2.png)
>
> 写在最后，Go运行时完整的调度系统是很复杂，很难用一篇文章描述的清楚，这里只能从宏观上介绍一下，让大家有个整体的认识。
>
> ```go
> // Goroutine1
> func task1() {
>     go task2()
>     go task3()
> }
> ```
>
> 假如我们有一个G(Goroutine1)已经通过P被安排到了一个M上正在执行，在Goroutine1执行的过程中我们又创建两个G，这两个G会被马上放入与Goroutine1相同的P的本地G任务队列中，排队等待与该P绑定的M的执行，这是最基本的结构，很好理解。 关键问题是:
> **a.如何在一个多核心系统上尽量合理分配G到多个M上运行，充分利用多核，提高并发能力呢？**
> 如果我们在一个Goroutine中通过**go**关键字创建了大量G，这些G虽然暂时会被放在同一个队列, 但如果这时还有空闲P（系统内P的数量默认等于系统cpu核心数），Go运行时系统始终能保证至少有一个（通常也只有一个）活跃的M与空闲P绑定去各种G队列去寻找可运行的G任务，该种M称为**自旋的M**。一般寻找顺序为：自己绑定的P的队列，全局队列，然后其他P队列。如果自己P队列找到就拿出来开始运行，否则去全局队列看看，由于全局队列需要锁保护，如果里面有很多任务，会转移一批到本地P队列中，避免每次都去竞争锁。如果全局队列还是没有，就要开始玩狠的了，直接从其他P队列偷任务了（偷一半任务回来）。这样就保证了在还有可运行的G任务的情况下，总有与CPU核心数相等的M+P组合 在执行G任务或在执行G的路上(寻找G任务)。
> **b. 如果某个M在执行G的过程中被G中的系统调用阻塞了，怎么办？**
> 在这种情况下，这个M将会被内核调度器调度出CPU并处于阻塞状态，与该M关联的其他G就没有办法继续执行了，但Go运行时系统的一个监控线程(sysmon线程)能探测到这样的M，并把与该M绑定的P剥离，寻找其他空闲或新建M接管该P，然后继续运行其中的G，大致过程如下图所示。然后等到该M从阻塞状态恢复，需要重新找一个空闲P来继续执行原来的G，如果这时系统正好没有空闲的P，就把原来的G放到全局队列当中，等待其他M+P组合发掘并执行。
>
> **c. 如果某一个G在M运行时间过长，有没有办法做抢占式调度，让该M上的其他G获得一定的运行时间，以保证调度系统的公平性?**
> 我们知道linux的内核调度器主要是基于时间片和优先级做调度的。对于相同优先级的线程，内核调度器会尽量保证每个线程都能获得一定的执行时间。为了防止有些线程"饿死"的情况，内核调度器会发起抢占式调度将长期运行的线程中断并让出CPU资源，让其他线程获得执行机会。当然在Go的运行时调度器中也有类似的抢占机制，但并不能保证抢占能成功，因为Go运行时系统并没有内核调度器的中断能力，它只能通过向运行时间过长的G中设置抢占flag的方法温柔的让运行的G自己主动让出M的执行权。 
> 说到这里就不得不提一下Goroutine在运行过程中可以动态扩展自己线程栈的能力，可以从初始的2KB大小扩展到最大1G（64bit系统上），因此在每次调用函数之前需要先计算该函数调用需要的栈空间大小，然后按需扩展（超过最大值将导致运行时异常）。Go抢占式调度的机制就是利用在判断要不要扩栈的时候顺便查看以下自己的抢占flag，决定是否继续执行，还是让出自己。
> 运行时系统的监控线程会计时并设置抢占flag到运行时间过长的G，然后G在有函数调用的时候会检查该抢占flag，如果已设置就将自己放入全局队列，这样该M上关联的其他G就有机会执行了。但如果正在执行的G是个很耗时的操作且没有任何函数调用(如只是for循环中的计算操作)，即使抢占flag已经被设置，该G还是将一直霸占着当前M直到执行完自己的任务。

### 2.5、Actor 和 CSP 模型

> “Don’t communicate by sharing memory, share memory by communicating”（不要通过共享内存来通信，而应该通过通信来共享内存）的思想.Actor 和 CSP 就是两种基于这种思想的并发编程模型

### Actor模型

在Actor模型中，主角是Actor，类似一种worker，Actor彼此之间直接发送消息，不需要经过什么中介，消息是异步发送和处理的：

![Actor模型](./image/common/Actor模型.jpeg)

Actor模型描述了一组为了避免并发编程的常见问题的公理:

- 1.所有Actor状态是Actor本地的，外部无法访问。
- 2.Actor必须只有通过消息传递进行通信。
- 3.一个Actor可以响应消息:推出新Actor,改变其内部状态,或将消息发送到一个或多个其他参与者。
- 4.Actor可能会堵塞自己,但Actor不应该堵塞它运行的线程

### CSP模型

> Go语言的CSP模型是由协程Goroutine与通道Channel实现：

Channel模型中，worker之间不直接彼此联系，而是通过不同channel进行消息发布和侦听。消息的发送者和接收者之间通过Channel松耦合，发送者不知道自己消息被哪个接收者消费了，接收者也不知道是哪个发送者发送的消息。

![CSP模型](./image/common/CSP模型.jpeg)

Go协程goroutine: 是一种轻量线程，它不是操作系统的线程，而是将一个操作系统线程分段使用，通过调度器实现协作式调度。是一种绿色线程，微线程，它与Coroutine协程也有区别，能够在发现堵塞后启动新的微线程。
通道channel: 类似Unix的Pipe，用于协程之间通讯和同步。协程之间虽然解耦，但是它们和Channel有着耦合。

**Actor模型和CSP区别**
Actor模型和CSP区别图如下：

![Actor和CSP模型对比](./image/common/Actor和CSP模型对比.png)

Actor之间直接通讯，而CSP是通过Channel通讯，在耦合度上两者是有区别的，后者更加松耦合。

同时，它们都是描述独立的流程通过消息传递进行通信。主要的区别在于：在CSP消息交换是同步的(即两个流程的执行"接触点"的，在此他们交换消息)，而Actor模型是完全解耦的，可以在任意的时间将消息发送给任何未经证实的接受者。由于Actor享有更大的相互独立,因为他可以根据自己的状态选择处理哪个传入消息。自主性更大些。

在Go语言中为了不堵塞流程，程序员必须检查不同的传入消息，以便预见确保正确的顺序。CSP好处是Channel不需要缓冲消息，而Actor理论上需要一个无限大小的邮箱作为消息缓冲。

## 3、并发

### a、Java

#### a.1、任务

| 接口名                                         | 说明                                |
| ---------------------------------------------- | ----------------------------------- |
| Runnable                                       | 无返回值                            |
| Callable<V>                                    | 有返回值V                           |
| Future<V>                                      | 有返回值V；可取消；可超时；可阻塞   |
| CompletableFuture<T>                           | 强大的异步任务整合能力；详见：7.1.1 |
| FutureTask -> RunnableFuture(Runnable、Future) | 整合Runnable\Feature                |
| ScheduledFuture、RunnableScheduledFuture       | 定时任务                            |

![任务](./image/java/并发/任务.png)

#### a.2、任务执行

| 任务执行                    | 说明                                                   |
| --------------------------- | ------------------------------------------------------ |
| Thread                      | 不建议直接使用                                         |
| ThreadPoolExecutor          | 线程池，可以控制队列大小，线程数量，解决策略           |
| Executors                   | 不推荐使用，建议通过ThreadPoolExecutor来进行精细化控制 |
| ForkJoinPool                |                                                        |
| ScheduledThreadPoolExecutor | 定时任务调度线程池                                     |

![任务执行](./image/java/并发/任务执行.png)

#### a.3、并发协调

| 功能      | 结构                                               | 说明 |
| --------- | -------------------------------------------------- | ---- |
| 锁        | ReentrantLock、ReentrantReadWriteLock、StampedLock |      |
| 等待-通知 | Object.wait/notify/notifyAll、Condition            |      |
| 信号量    | Semaphore                                          |      |
| 栅栏      | CountDownLatch、CyclicBarrier                      |      |
| 关键字    | volatile、synchronized                             |      |



#### a.4、数据结构

| 接口          | 非线程安全                      | 线程安全                                                     |
| ------------- | ------------------------------- | ------------------------------------------------------------ |
| List          | ArrayList、LinkedList           | CopyOnWriteArrayList                                         |
| Map           | HashMap、LinkedHashMap、TreeMap | ConcurrentHashMap、ConcurrentSkipListMap                     |
| Set           | HashSet、TreeSet                | CopyOnWriteArraySet、ConcurrentSkipListSet                   |
| Queue         | ArrayDeque、LinkedList          |                                                              |
| Deque         | ArrayDeque、LinkedList          |                                                              |
| BlockingQueue | --                              | ArrayBlockingQueue、LinkedBlockingQueue<br>ConcurrentLinkedQueue、LinkedTransferQueue<br>PriorityBlockingQueue、SynchronousQueue |
| BlockingDeque | --                              | ConcurrentLinkedDeque 、LinkedBlockingDeque                  |
|               |                                 |                                                              |

![队列](./image/java/并发/队列.png)

![Map](./image/java/并发/Map.png)

### b、Go

#### b.1、任务

任意一个函数数都可以作为并发的任务。

#### b.2、任务执行

函数调用时，使用go关键字调用，就会自动作为异步任务执行，系统会通过Go的协程进行自动调度。

#### b.3、并发协调

| 功能      | 结构                     | 说明                    |
| --------- | ------------------------ | ----------------------- |
| 锁        | sync.Mutex、sync.RWMutex |                         |
| 等待-通知 | sync.Cond                | Wait、Signal、Broadcast |
| 信号量    | --                       |                         |
| 栅栏      | sync.WaitGroup           |                         |

#### b.4、数据结构

| 接口    | 线程安全            | 说明                                                        |
| ------- | ------------------- | ----------------------------------------------------------- |
| channel | chan、buffered chan | 类似Java中的BlockingQueue，是Go语言中推荐的一种并发编程范式 |

# 反射

# 泛型

## 1、引入泛型的原因

泛型是什么意思，为什么我们想要呢？

> **当你需要针对不同类型书写同样的逻辑，使用泛型来简化代码是最好的**

用 [Jazayeri等人的话来说](https://link.zhihu.com/?target=https%3A//www.dagstuhl.de/en/program/calendar/semhp/%3Fsemnr%3D98171)：泛型编程能够以通用类型的形式表示函数和数据结构。

假设我们想要反转切片中的元素：

```Go
func ReverseInts(s []int) {
    first := 0
    last := len(s) - 1
    for first < last {
        s[first], s[last] = s[last], s[first]
        first++
        last--
    }
}

func ReverseStrings(s []string) {
    first := 0
    last := len(s) - 1
    for first < last {
        s[first], s[last] = s[last], s[first]
        first++
        last--
    }
}
```

如果比较ReverseInts以及ReverseStrings，您将看到两个函数完全相同，除了参数的类型。我认为没有任何读者对此感到惊讶。

有些人对Go感到惊讶的是，没有办法编写Reverse适用于任何类型切片的简单函数。

在像Python或JavaScript这样的动态类型语言中，您可以简单地编写函数，而无需指定元素类型。这在Go中不起作用，因为Go是静态类型的，并且要求您记下切片的确切类型和切片元素的类型。

大多数其他静态类型语言，如C++或Java或Rust或Swift，支持泛型来解决这类问题。

## 2、泛型实现

参考：

- C++泛型： https://zhuanlan.zhihu.com/p/55104997
- Java泛型：https://dunwu.github.io/blog/pages/33a820

### 2.1、C++（模板）

C++ 的泛型编程是基于模板实现的，而 C++ 的模板采用的是代码膨胀技术。例如 std::list 容器，如果你将 int 类型的数据存进去，C++ 编译器就为你生成一个专门用来存 int 类型数据的列表数据结构。也就是说，你向 std::list 容器中存放什么类型，C++ 编译器就为你生成相应的列表数据结构。理论上，数据的类型是无限的，因此 C++ 要生成的列表数据结构也是无限的。如果你的程序中有大量的数据类型要存到 std::list 容器，那么代码就会高度膨胀，这种膨胀是 C++ 编译器在目标文件连接阶段无法优化的。

Effective C++》的作者可能见过代码膨胀的例子，所以他在条款 44 中建议『将与参数无关的代码抽离 templates』。这个条款也许是 C++ 应对模板导致的代码膨胀问题的唯一解决方案了，然而这个方案往往并不是那么容易实现。你需要仔细审度你的代码，认真的从模板类（或模板函数）中将那些不涉及模板参数的代码抽离出来做成基类（或辅助函数）。即使你能很好的做到这一点，但是请认真想一想，这样做真的有意义么？

模板技术原本是为了简化编程任务而被提出来的，但是要消除模板带来的代码膨胀，你不得不对本来逻辑很清晰的代码进行肢解再重新整合，这个过程或多或少的会破坏甚至扭曲原有的代码逻辑，结果弄出来一个浑身插着电源线的怪兽般的模板类或模板函数。

C++ 模板代码所导致的膨胀，主要带来以下问题：

1. 源代码膨胀了，因为程序猿要做『将与参数无关的代码从模板中抽离』这件事。有人做过试验，即使是一个不太大的 List 实现，将代码从模板中抽离后，导致源代码膨胀了 20%……其实开发效率也自然降低了很多。
2. 编译时间被拖长了，因为编译器在代码编译阶段要对模板代码进行『惰性计算』，要产生模板的实例代码，在目标文件连接阶段还要消除各个目标文件中重复的模板代码。
3. 目标文件膨胀了。有人说他用 boost::spirit 实现了一个很小的语法解析器，开了 GCC 的最大化优化选项，目标文件也要几十 MB，而一个 Lua 或 Python 解释器还不到 1 MB，Haskell 的解释器 ghc 刚 1 MB 多一点……
4. 模板代码中如果存在错误，编译器产生的错误信息也膨胀了，特别是模板类的嵌套嵌套再嵌套，或者模板实例非常多的时候，编译出错信息无法卒读，甚至有人说编译出错信息甚至超出了他用的文本编辑器的缓存空间大小。

### 2.2、Java（类型擦除）

Java 语言引入泛型是为了在编译时提供更严格的类型检查，并支持泛型编程。不同于 C++ 的模板机制，Java 泛型是使用类型擦除来实现的，使用泛型时，任何具体的类型信息都被擦除了。

那么，类型擦除做了什么呢？它做了以下工作：

1. 把泛型中的所有类型参数替换为 Object，如果指定类型边界，则使用类型边界来替换。因此，生成的字节码仅包含普通的类，接口和方法。
2. 擦除出现的类型声明，即去掉 <> 的内容。比如 T get() 方法声明就变成了 Object get() ；List<String> 就变成了 List。如有必要，插入类型转换以保持类型安全。
3. 生成桥接方法以保留扩展泛型类型中的多态性。类型擦除确保不为参数化类型创建新类；因此，泛型不会产生运行时开销。

**泛型不能用于显式地引用运行时类型的操作之中，例如：转型、instanceof 操作和 new 表达式。因为所有关于参数的类型信息都丢失了**。当你在编写泛型代码时，必须时刻提醒自己，你只是看起来好像拥有有关参数的类型信息而已。

正是由于泛型时基于类型擦除实现的，所以，**泛型类型无法向上转型**。

> 向上转型是指用子类实例去初始化父类，这是面向对象中多态的重要表现。

`Integer` 继承了 `Object`；`ArrayList` 继承了 `List`；但是 `List<Interger>` 却并非继承了 `List<Object>`。这是因为，泛型类并没有自己独有的 `Class` 类对象。比如：并不存在 `List<Object>.class` 或是 `List<Interger>.class`，Java 编译器会将二者都视为 `List.class`。

**Java上下界**

继承关系：C --> B --> A --> Object

|      | 上界                                                         | 下界                                                         |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 形式 | <? extends B>                                                | <? super B>                                                  |
| 含义 | 参数化的类型可能是所指定的类或者其任意**子类 **<br>参数类型可以是类B或C | 参数化的类型可能是所指定的类型或者其任意**父类**<br>参数类型可以是类B、A、Object |
| Add  | --                                                           | B及其子类                                                    |
| get  | B                                                            | Object类型                                                   |

1、Java上界：

- 形式：`<? extends B>`，泛型的**上界**就是 B 类

- 含义：表示参数化的类型可能是所指定的类或者其任意**子类**，参数类型可以是B、C

- 操作：只读（只能读取，不能添加）

- add操作：不支持

  ```java
  // 泛型为：List<? extends B>
  // 实例可以为：List<B>、List<C>
  // 我们无法将某种元素无障碍的添加到所有的上述类型实例中，如果我向一个List<C>中添加一个元素B，因为B无法向下转型为C，从而导致出错，所以上界不支持add操作.不是所愿的元素都可以向上转型的。
  ```

- get操作：作为B类型读出

  ```java
  // 我们可以从上述的任何一种实例类型中获取元素时，获取出来的元素都可以作为B类型对待
  ```

2、Java下界：

- 形式：<? super B>，泛型的下界就是 B 类

- 含义：表示参数化的类型可能是所指定的类型或者其任意**父类**，参数类型可以是B、A、Object

- 操作：可读可写（可写B及其子类，只能读出Object类型）

- add操作：可添加B及其子类

  ```java
  // 泛型为：List<? super B>
  // 实例可以为：List<B>、List<A>、List<Object>
  // 无论你向上述哪一种实例中添加B或Bd子类元素都是可以的，因为Java可以支持无障碍的向上转型
  ```

- get操作：只能读出Object

  ```java
  // 我们可以从上述任一实例类型中获取元素，获取出来的元素可能为B、A、Object。
  // 因此我们只能认为获取出来的元素为Object，而无法将其确认为B或A。
  // 因为如果是Object，将无法转型为B、A，而如果是B或A，我们可以将其向上转型为Object。
  ```

### 2.3、Go

Go泛型提案中关于泛型实现的介绍

Go的泛型有别于其它语言的方案，在Go语言中泛型叫做Type Parameter(类型参数).

Taylor和Griesemer的提案Type Parameters Proposal更多的是泛型呈现形式和影响的思考,对具体的实现涉及甚少。

无论什么编程语言，根据Russ Cox的观察，实现泛型至少要面对下面三条困境之一,那还是在2009年：

1. **拖累程序员**: 比如C语言，增加了程序员的负担，需要曲折的实现，但是不对增加语言的复杂性
2. **拖累编译器**: 比如C++编程语言，增加了编译器的负担，可能会产生很多冗余的代码，重复的代码还需要编译器斟酌删除，编译的文件可能非常大。Rust的泛型也属于这一类。
3. **拖累执行时间**: 比如Java，将一些装箱成Object,进行类型擦除。虽然代码没啥冗余了，空间节省了，但是需要装箱拆箱操作，代码效率低。很显然, Go语言至简的设计哲学让它的泛型实现不会选择增加程序员的负担的道路，所以它会在第二和第三种方案中做选择。虽然提案中没有最终说明它选择了哪种方案，但是从实际编译的代码可以看出，它选择的是第二种方案。
   ————————————————
   原文链接：https://blog.csdn.net/RA681t58CJxsgCkJ31/article/details/120029906

泛型能实现的功能通过接口+反射也基本能实现。但是使用过反射的人都知道反射机制有很多问题：

1. 用起来麻烦
2. 失去了编译时的类型检查，不仔细写容易出错
3. 性能不太理想

而在泛型适用的时候，它能解决上面这些问题。但这也不意味着泛型是万金油，泛型有着自己的适用场景，当你疑惑是不是该用泛型的话，请记住下面这条经验：

> 如果你经常要分别为不同的类型写完全相同逻辑的代码，那么使用泛型将是最合适的选择

## 3、泛型类型

泛型类型：是被参数化的类、接口、函数、数据结构(Struct)。

### 3.1、Go的泛型

参考链接： https://segmentfault.com/a/1190000041634906

#### 3.1.1、Go泛型概念

Go1.18也是通过这种方式实现的泛型，但是单纯的形参实参是远远不能实现泛型编程的，所以Go还引入了非常多全新的概念：

1. 类型形参 (Type parameter)
2. 类型实参(Type argument)
3. 类型形参列表( Type parameter list)
4. 类型约束(Type constraint)
5. 实例化(Instantiations)
6. 泛型类型(Generic type)
7. 泛型接收器(Generic receiver)
8. 泛型函数(Generic function)

#### 3.1.2、类型形参、类型实参、类型约束和泛型类型

![泛型概念](./image/go/泛型概念.png)

#### 3.1.3、泛型方法/接收器(receiver)

#### 3.1.4、泛型函数

#### 3.1.5、变复杂的接口

##### 1、简化约束

有时候使用泛型编程时，我们会书写长长的类型约束，如下：

```go
// 一个可以容纳所有int,uint以及浮点类型的泛型切片
type Slice[T int | int8 | int16 | int32 | int64 | uint | uint8 | uint16 | uint32 | uint64 | float32 | float64] []T
```

理所当然，这种写法是我们无法忍受也难以维护的，而Go支持将类型约束单独拿出来定义到接口中，从而让代码更容易维护：

```go
type IntUintFloat interface {
    int | int8 | int16 | int32 | int64 | uint | uint8 | uint16 | uint32 | uint64 | float32 | float64
}

type Slice[T IntUintFloat] []T
```

这段代码把类型约束给单独拿出来，写入了接口类型 `IntUintFloat` 当中。需要指定类型约束的时候直接使用接口 `IntUintFloat` 即可。

不过这样的代码依旧不好维护，而接口和接口、接口和普通类型之间也是可以通过 `|` 进行组合：

```go
type Int interface {
    int | int8 | int16 | int32 | int64
}

type Uint interface {
    uint | uint8 | uint16 | uint32
}

type Float interface {
    float32 | float64
}

type Slice[T Int | Uint | Float] []T  // 使用 '|' 将多个接口类型组合
```

上面的代码中，我们分别定义了 Int, Uint, Float 三个接口类型，并最终在 Slice[T] 的类型约束中通过使用 `|` 将它们组合到一起。

同时，在接口里也能直接组合其他接口，所以还可以像下面这样：

```go
type SliceElement interface {
    Int | Uint | Float | string // 组合了三个接口类型并额外增加了一个 string 类型
}

type Slice[T SliceElement] []T 
```

##### 2、`~` : 指定底层类型

上面定义的 Slie[T] 虽然可以达到目的，但是有一个缺点：

```go
var s1 Slice[int] // 正确 

type MyInt int
var s2 Slice[MyInt] // ✗ 错误。MyInt类型底层类型是int但并不是int类型，不符合 Slice[T] 的类型约束
```

这里发生错误的原因是，泛型类型 Slice[T] 允许的是 int 作为类型实参，而不是 MyInt （虽然 MyInt 类型底层类型是 int ，但它依旧不是 int 类型）。

为了从根本上解决这个问题，Go新增了一个符号 `~` ，在类型约束中使用类似 `~int` 这种写法的话，就代表着不光是 int ，所有以 int 为底层类型的类型也都可用于实例化。

使用 ~ 对代码进行改写之后如下：

```go
type Int interface {
    ~int | ~int8 | ~int16 | ~int32 | ~int64
}

type Uint interface {
    ~uint | ~uint8 | ~uint16 | ~uint32
}
type Float interface {
    ~float32 | ~float64
}

type Slice[T Int | Uint | Float] []T 

var s Slice[int] // 正确

type MyInt int
var s2 Slice[MyInt]  // MyInt底层类型是int，所以可以用于实例化

type MyMyInt MyInt
var s3 Slice[MyMyInt]  // 正确。MyMyInt 虽然基于 MyInt ，但底层类型也是int，所以也能用于实例化

type MyFloat32 float32  // 正确
var s4 Slice[MyFloat32]
```

**限制**：使用 `~` 时有一定的限制：

1. ~后面的类型不能为接口
2. ~后面的类型必须为基本类型

```go
type MyInt int

type _ interface {
    ~[]byte  // 正确
    ~MyInt   // 错误，~后的类型必须为基本类型
    ~error   // 错误，~后的类型不能为接口
}
```

##### 3、从方法集(Method set)到类型集(Type set)

上面的例子中，我们学习到了一种接口的全新写法，而这种写法在Go1.18之前是不存在的。如果你比较敏锐的话，一定会隐约认识到这种写法的改变这也一定意味着Go语言中 `接口(interface)` 这个概念发生了非常大的变化。

是的，在Go1.18之前，Go官方对 `接口(interface)` 的定义是：接口是一个方法集(method set)

> An interface type specifies a **method set** called its interface

就如下面这个代码一样， `ReadWriter` 接口定义了一个接口(方法集)，这个集合中包含了 `Read()` 和 `Write()` 这两个方法。所有同时定义了这两种方法的类型被视为实现了这一接口。

```go
type ReadWriter interface {
    Read(p []byte) (n int, err error)
    Write(p []byte) (n int, err error)
}
```

但是，我们如果换一个角度来重新思考上面这个接口的话，会发现接口的定义实际上还能这样理解：

> 我们可以把 `ReaderWriter` 接口看成代表了一个 **类型的集合**，所有实现了 `Read()` `Writer()` 这两个方法的类型都在接口代表的类型集合当中

通过换个角度看待接口，在我们眼中接口的定义就从 **`方法集(method set)`** 变为了 **`类型集(type set)`**。而Go1.18开始就是依据这一点将接口的定义正式更改为了 **类型集(Type set)**

> An interface type defines a ***type set\*** *(一个*接口类型定义了一个类型集)

你或许会觉得，这不就是改了下概念上的定义实际上没什么用吗？是的，如果接口功能没变化的话确实如此。但是还记得下面这种用接口来简化类型约束的写法吗：

```go
type Float interface {
    ~float32 | ~float64
}

type Slice[T Float] []T 
```

这就体现出了为什么要更改接口的定义了。用 **类型集** 的概念重新理解上面的代码的话就是：

> 接口类型 Float 代表了一个 **类型集合**， 所有以 float32 **或** float64 为底层类型的类型，都在这一类型集之中

而 `type Slice[T Float] []T` 中， **类型约束** 的真正意思是：

> **类型约束** 指定了类型形参可接受的类型集合，只有属于这个集合中的类型才能替换形参用于实例化

如：

```go
var s Slice[int]      // int 属于类型集 Float ，所以int可以作为类型实参
var s Slice[chan int] // chan int 类型不在类型集 Float 中，所以错误
```

###### 3.1 接口实现(implement)定义的变化

既然接口定义发生了变化，那么从Go1.18开始 `接口实现(implement)` 的定义自然也发生了变化：

当满足以下条件时，我们可以说 **类型 T 实现了接口 I ( type T implements interface I)**：

- T 不是接口时：类型 T 是接口 I 代表的类型集中的一个成员 (T is an element of the type set of I)
- T 是接口时： T 接口代表的类型集是 I 代表的类型集的子集(Type set of T is a subset of the type set of I)

###### 3.2 类型的并集

并集我们已经很熟悉了，之前一直使用的 `|` 符号就是求类型的并集( `union` )

```go
type Uint interface {  // 类型集 Uint 是 ~uint 和 ~uint8 等类型的并集
    ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64
}
```

###### 3.3 类型的交集

接口可以不止书写一行，如果一个接口有多行类型定义，那么取它们之间的 **交集**

```go
type AllInt interface {
    ~int | ~int8 | ~int16 | ~int32 | ~int64 | ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint32
}

type Uint interface {
    ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64
}

type A interface { // 接口A代表的类型集是 AllInt 和 Uint 的交集
    AllInt
    Uint
}

type B interface { // 接口B代表的类型集是 AllInt 和 ~int 的交集
    AllInt
    ~int
}
```

上面这个例子中

- 接口 A 代表的是 AllInt 与 Uint 的 **交集**，即 `~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64`
- 接口 B 代表的则是 AllInt 和 ~int 的**交集**，即 `~int`

除了上面的交集，下面也是一种交集：

```go
type C interface {
    ~int
    int
}
```

很显然，~int 和 int 的交集只有int一种类型，所以接口C代表的类型集中只有int一种类型

###### 3.4 空集

当多个类型的交集如下面 `Bad` 这样为空的时候， `Bad` 这个接口代表的类型集为一个**空集**：

```go
type Bad interface {
    int
    float32 
} // 类型 int 和 float32 没有相交的类型，所以接口 Bad 代表的类型集为空
```

**没有任何一种类型属于空集**。虽然 Bad 这样的写法是可以编译的，但实际上并没有什么意义

###### 3.5 空接口和 any

上面说了空集，接下来说一个特殊的类型集——`空接口 interface{}` 。因为，Go1.18开始接口的定义发生了改变，所以 `interface{}` 的定义也发生了一些变更：

> 空接口代表了所有类型的集合

所以，对于Go1.18之后的空接口应该这样理解：

1. 虽然空接口内没有写入任何的类型，但它代表的是所有类型的集合，而非一个 **空集**

2. 类型约束中指定 **空接口** 的意思是指定了一个包含所有类型的类型集，并不是类型约束限定了只能使用 **空接口** 来做类型形参

   ```go
   // 空接口代表所有类型的集合。写入类型约束意味着所有类型都可拿来做类型实参
   type Slice[T interface{}] []T
   
   var s1 Slice[int]    // 正确
   var s2 Slice[map[string]string]  // 正确
   var s3 Slice[chan int]  // 正确
   var s4 Slice[interface{}]  // 正确
   ```

因为空接口是一个包含了所有类型的类型集，所以我们经常会用到它。于是，Go1.18开始提供了一个和空接口 `interface{}` 等价的新关键词 `any` ，用来使代码更简单：

```go
type Slice[T any] []T // 代码等价于 type Slice[T interface{}] []T
```

实际上 `any` 的定义就位于Go语言的 `builtin.go` 文件中（参考如下）， `any` 实际上就是 `interaface{}` 的别名(alias)，两者完全等价

```go
// any is an alias for interface{} and is equivalent to interface{} in all ways.
type any = interface{} 
```

所以从 Go 1.18 开始，所有可以用到空接口的地方其实都可以直接替换为any，如：

```go
var s []any // 等价于 var s []interface{}
var m map[string]any // 等价于 var m map[string]interface{}

func MyPrint(value any){
    fmt.Println(value)
}
```

如果你高兴的话，项目迁移到 Go1.18 之后可以使用下面这行命令直接把整个项目中的空接口全都替换成 any。当然因为并不强制，所以到底是用 `interface{}` 还是 `any` 全看自己喜好

```go
gofmt -w -r 'interface{} -> any' ./...
```

> 💡 Go语言项目中就曾经有人提出过把Go语言中所有 interface{ }替换成 any 的 [issue](https://link.segmentfault.com/?enc=Zl2qV2MbrXdoqmUNqhO7iA%3D%3D.Rd7wRuVzF6fuJnK%2BZY%2FRXIYd4tcYqLN%2FS%2FlPEm3BBxGLBJyxs9T0CBgLK47strJO)，然后因为影响范围过大过而且影响因素不确定，理所当然被驳回了

###### 3.6 comparable(可比较) 和 可排序(ordered)

对于一些数据类型，我们需要在类型约束中限制只接受能 `!=` 和 `==` 对比的类型，如map：

```go
// 错误。因为 map 中键的类型必须是可进行 != 和 == 比较的类型
type MyMap[KEY any, VALUE any] map[KEY]VALUE 
```

所以Go直接内置了一个叫 `comparable` 的接口，它代表了所有可用 `!=` 以及 `==` 对比的类型：

```go
type MyMap[KEY comparable, VALUE any] map[KEY]VALUE // 正确
```

`comparable` 比较容易引起误解的一点是很多人容易把他与可排序搞混淆。可比较指的是 可以执行 `!=` `==` 操作的类型，并没确保这个类型可以执行大小比较（ `>,<,<=,>=` ）。如下：

```go
type OhMyStruct struct {
    a int
}

var a, b OhMyStruct

a == b // 正确。结构体可使用 == 进行比较
a != b // 正确

a > b // 错误。结构体不可比大小
```

而可进行大小比较的类型被称为 `Orderd` 。目前Go语言并没有像 `comparable` 这样直接内置对应的关键词，所以想要的话需要自己来定义相关接口，比如我们可以参考Go官方包`golang.org/x/exp/constraints` 如何定义：

```go
// Ordered 代表所有可比大小排序的类型
type Ordered interface {
    Integer | Float | ~string
}

type Integer interface {
    Signed | Unsigned
}

type Signed interface {
    ~int | ~int8 | ~int16 | ~int32 | ~int64
}

type Unsigned interface {
    ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr
}

type Float interface {
    ~float32 | ~float64
}
```

> 💡 这里虽然可以直接使用官方包 [golang.org/x/exp/constraints](https://link.segmentfault.com/?enc=7QSDRSLyYqoA%2BmatKSG52A%3D%3D.HY89r3sYM5ETAOFgYiDXKlIc6HImzNeAoavxJQgvpkGeOvaOf19h3zCE2cKfbMkc) ，但因为这个包属于实验性质的 x 包，今后可能会发生非常大变动，所以并不推荐直接使用

##### 4、 接口两种类型

我们接下来再观察一个例子，这个例子是阐述接口是类型集最好的例子：

```go
type ReadWriter interface {
    ~string | ~[]rune

    Read(p []byte) (n int, err error)
    Write(p []byte) (n int, err error)
}
```

最开始看到这一例子你一定有点懵不太理解它代表的意思，但是没关系，我们用类型集的概念就能比较轻松理解这个接口的意思：

> 接口类型 ReadWriter 代表了一个类型集合，所有以 string 或 []rune 为底层类型，并且实现了 Read() Write() 这两个方法的类型都在 ReadWriter 代表的类型集当中

如下面代码中，StringReadWriter 存在于接口 ReadWriter 代表的类型集中，而 BytesReadWriter 因为底层类型是 []byte（既不是string也是不[]rune） ，所以它不属于 ReadWriter 代表的类型集

```go
// 类型 StringReadWriter 实现了接口 Readwriter
type StringReadWriter string 

func (s StringReadWriter) Read(p []byte) (n int, err error) {
    // ...
}

func (s StringReadWriter) Write(p []byte) (n int, err error) {
 // ...
}

//  类型BytesReadWriter 没有实现接口 Readwriter
type BytesReadWriter []byte 

func (s BytesReadWriter) Read(p []byte) (n int, err error) {
 ...
}

func (s BytesReadWriter) Write(p []byte) (n int, err error) {
 ...
}
```

你一定会说，啊等等，这接口也变得太复杂了把，那我定义一个 `ReadWriter` 类型的接口变量，然后接口变量赋值的时候不光要考虑到方法的实现，还必须考虑到具体底层类型？心智负担也太大了吧。是的，为了解决这个问题也为了保持Go语言的兼容性，Go1.18开始将接口分为了两种类型

- **基本接口(Basic interface)**
- **一般接口(General interface)**

###### 4.1 基本接口(Basic interface)

接口定义中如果只有方法的话，那么这种接口被称为**基本接口(Basic interface)**。这种接口就是Go1.18之前的接口，用法也基本和Go1.18之前保持一致。基本接口大致可以用于如下几个地方：

- 最常用的，定义接口变量并赋值

  ```go
  type MyError interface { // 接口中只有方法，所以是基本接口
      Error() string
  }
  
  // 用法和 Go1.18之前保持一致
  var err MyError = fmt.Errorf("hello world")
  ```

- 基本接口因为也代表了一个类型集，所以也可用在类型约束中

  ```go
  // io.Reader 和 io.Writer 都是基本接口，也可以用在类型约束中
  type MySlice[T io.Reader | io.Writer]  []Slice
  ```

###### 4.2 一般接口(General interface)

如果接口内不光只有方法，还有类型的话，这种接口被称为 **一般接口(General interface)** ，如下例子都是一般接口：

```go
type Uint interface { // 接口 Uint 中有类型，所以是一般接口
    ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64
}

type ReadWriter interface {  // ReadWriter 接口既有方法也有类型，所以是一般接口
    ~string | ~[]rune

    Read(p []byte) (n int, err error)
    Write(p []byte) (n int, err error)
}
```

**一般接口类型不能用来定义变量，只能用于泛型的类型约束中**。所以以下的用法是错误的：

```go
type Uint interface {
    ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64
}

var uintInf Uint // 错误。Uint是一般接口，只能用于类型约束，不得用于变量定义
```

这一限制保证了一般接口的使用被限定在了泛型之中，不会影响到Go1.18之前的代码，同时也极大减少了书写代码时的心智负担

##### 5、泛型接口

所有类型的定义中都可以使用类型形参，所以接口定义自然也可以使用类型形参，观察下面这两个例子：

```go
type DataProcessor[T any] interface {
    Process(oriData T) (newData T)
    Save(data T) error
}

type DataProcessor2[T any] interface {
    int | ~struct{ Data interface{} }

    Process(data T) (newData T)
    Save(data T) error
}
```

因为引入了类型形参，所以这两个接口是泛型类型。**而泛型类型要使用的话必须传入类型实参实例化才有意义**。所以我们来尝试实例化一下这两个接口。因为 `T` 的类型约束是 any，所以可以随便挑一个类型来当实参(比如string)：

```go
DataProcessor[string]

// 实例化之后的接口定义相当于如下所示：
type DataProcessor[string] interface {
    Process(oriData string) (newData string)
    Save(data string) error
}
```

经过实例化之后就好理解了， `DataProcessor[string]` 因为只有方法，所以它实际上就是个 **基本接口(Basic interface)**，这个接口包含两个能处理string类型的方法。像下面这样实现了这两个能处理string类型的方法就算实现了这个接口：

```go
type CSVProcessor struct {
}

// 注意，方法中 oriData 等的类型是 string
func (c CSVProcessor) Process(oriData string) (newData string) {
    ....
}

func (c CSVProcessor) Save(oriData string) error {
    ...
}

// CSVProcessor实现了接口 DataProcessor[string] ，所以可赋值
var processor DataProcessor[string] = CSVProcessor{}  
processor.Process("name,age\nbob,12\njack,30")
processor.Save("name,age\nbob,13\njack,31")

// 错误。CSVProcessor没有实现接口 DataProcessor[int]
var processor2 DataProcessor[int] = CSVProcessor{}
```

再用同样的方法实例化 `DataProcessor2[T]` ：

```go
DataProcessor2[string]

// 实例化后的接口定义可视为
type DataProcessor2[T string] interface {
    int | ~struct{ Data interface{} }

    Process(data string) (newData string)
    Save(data string) error
}
```

`DataProcessor2[string]` 因为带有类型并集所以它是 **一般接口(General interface)**，所以实例化之后的这个接口代表的意思是：

1. 只有实现了 `Process(string) string` 和 `Save(string) error` 这两个方法，并且以 `int` 或 `struct{ Data interface{} }` 为底层类型的类型才算实现了这个接口
2. **一般接口(General interface)** 不能用于变量定义只能用于类型约束，所以接口 `DataProcessor2[string]` 只是定义了一个用于类型约束的类型集

```go
// XMLProcessor 虽然实现了接口 DataProcessor2[string] 的两个方法，但是因为它的底层类型是 []byte，所以依旧是未实现 DataProcessor2[string]
type XMLProcessor []byte

func (c XMLProcessor) Process(oriData string) (newData string) {

}

func (c XMLProcessor) Save(oriData string) error {

}

// JsonProcessor 实现了接口 DataProcessor2[string] 的两个方法，同时底层类型是 struct{ Data interface{} }。所以实现了接口 DataProcessor2[string]
type JsonProcessor struct {
    Data interface{}
}

func (c JsonProcessor) Process(oriData string) (newData string) {

}

func (c JsonProcessor) Save(oriData string) error {

}

// 错误。DataProcessor2[string]是一般接口不能用于创建变量
var processor DataProcessor2[string]

// 正确，实例化之后的 DataProcessor2[string] 可用于泛型的类型约束
type ProcessorList[T DataProcessor2[string]] []T

// 正确，接口可以并入其他接口
type StringProcessor interface {
    DataProcessor2[string]

    PrintString()
}

// 错误，带方法的一般接口不能作为类型并集的成员(参考6.5 接口定义的种种限制规则
type StringProcessor interface {
    DataProcessor2[string] | DataProcessor2[[]byte]

    PrintString()
}
```

##### 6、接口定义的种种限制规则

Go1.18从开始，在定义类型集(接口)的时候增加了非常多十分琐碎的限制规则，其中很多规则都在之前的内容中介绍过了，但剩下还有一些规则因为找不到好的地方介绍，所以在这里统一介绍下：

1. 用 `|` 连接多个类型的时候，类型之间不能有相交的部分(即必须是不交集):

   ```go
   type MyInt int
   
   // 错误，MyInt的底层类型是int,和 ~int 有相交的部分
   type _ interface {
       ~int | MyInt
   }
   ```

   但是相交的类型中是接口的话，则不受这一限制：

   ```go
   type MyInt int
   
   type _ interface {
       ~int | interface{ MyInt }  // 正确
   }
   
   type _ interface {
       interface{ ~int } | MyInt // 也正确
   }
   
   type _ interface {
       interface{ ~int } | interface{ MyInt }  // 也正确
   }
   ```

2. 类型的并集中不能有类型形参

   ```go
   type MyInf[T ~int | ~string] interface {
       ~float32 | T  // 错误。T是类型形参
   }
   
   type MyInf2[T ~int | ~string] interface {
       T  // 错误
   }
   ```

3. 接口不能直接或间接地并入自己

   ```go
   type Bad interface {
       Bad // 错误，接口不能直接并入自己
   }
   
   type Bad2 interface {
       Bad1
   }
   type Bad1 interface {
       Bad2 // 错误，接口Bad1通过Bad2间接并入了自己
   }
   
   type Bad3 interface {
       ~int | ~string | Bad3 // 错误，通过类型的并集并入了自己
   }
   ```

4. 接口的并集成员个数大于一的时候不能直接或间接并入 `comparable` 接口

   ```javascript
   type OK interface {
       comparable // 正确。只有一个类型的时候可以使用 comparable
   }
   
   type Bad1 interface {
       []int | comparable // 错误，类型并集不能直接并入 comparable 接口
   }
   
   type CmpInf interface {
       comparable
   }
   type Bad2 interface {
       chan int | CmpInf  // 错误，类型并集通过 CmpInf 间接并入了comparable
   }
   type Bad3 interface {
       chan int | interface{comparable}  // 理所当然，这样也是不行的
   }
   ```

5. 带方法的接口(无论是基本接口还是一般接口)，都不能写入接口的并集中：

   ```go
   type _ interface {
       ~int | ~string | error // 错误，error是带方法的接口(一般接口) 不能写入并集中
   }
   
   type DataProcessor[T any] interface {
       ~string | ~[]byte
   
       Process(data T) (newData T)
       Save(data T) error
   }
   
   // 错误，实例化之后的 DataProcessor[string] 是带方法的一般接口，不能写入类型并集
   type _ interface {
       ~int | ~string | DataProcessor[string] 
   }
   
   type Bad[T any] interface {
       ~int | ~string | DataProcessor[T]  // 也不行
   }
   ```

##### 7. 总结

至此，终于是从头到位把Go1.18的泛型给介绍完毕了。因为Go这次引入泛型带入了挺大的复杂度，也增加了挺多比较零散琐碎的规则限制。泛型虽然很受期待，但实际上推荐的使用场景也并没有那么广泛，对于泛型的使用，我们应该遵守下面的规则：

> 泛型并不取代Go1.18之前用接口+反射实现的动态类型，在下面情景的时候非常适合使用泛型：当你需要针对不同类型书写同样的逻辑，使用泛型来简化代码是最好的 (比如你想写个队列，写个链表、栈、堆之类的数据结构）

## 4、泛型使用

### 4.1、Java

#### 1、泛型函数

```java
public final class Objects {
		public static <T> int compare(T a, T b, Comparator<? super T> c) {
        return (a == b) ? 0 :  c.compare(a, b);
    }
  	// ......
}
```

#### 2、泛型接口

```java
@FunctionalInterface
public interface Supplier<T> {
    T get();
}

@FunctionalInterface
public interface Consumer<T> {
    void accept(T t);
}

@FunctionalInterface
public interface Function<T, R> {
    R apply(T t);
}

@FunctionalInterface
public interface Predicate<T> {
    boolean test(T t);
}

@FunctionalInterface
public interface BiFunction<T, U, R> {
    R apply(T t, U u);
  
  	default <V> BiFunction<T, U, V> andThen(Function<? super R, ? extends V> after) {
        Objects.requireNonNull(after);
        return (T t, U u) -> after.apply(apply(t, u));
    }
}
```

#### 3、泛型类（数据结构也是类）

```java
public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable
{
  // ......
}
```

#### 4、函数参数为上界/下界的含义

```java
public final class Objects {
		public static <T> int compare(T a, T b, Comparator<? super T> c) {
        return (a == b) ? 0 :  c.compare(a, b);
    }
  	// ......
}
// ----------------------------------------------------------------------------------
@FunctionalInterface
public interface BiFunction<T, U, R> {
    R apply(T t, U u);
  
  	default <V> BiFunction<T, U, V> andThen(Function<? super R, ? extends V> after) {
        Objects.requireNonNull(after);
        return (T t, U u) -> after.apply(apply(t, u));
    }
}
// after.apply(apply(t, u));  分解为：apply(t, u)、after.apply(v)
// apply(t, u) ：返回值为R类型，输入参数为T、U  BiFunction<T, U, R>
// after.apply(v)：返回类型为V或其子类，输入参数类型为R或其父类  Function<? super R, ? extends V> 
// apply(t, u)返回类型R作为after.apply(v)的参数，after为了保持兼容，可以接受R及其父类型作为输入，可以返回V及其子类型作为结果返回，对编程使用者提供了比较宽松的编程范式。
```

### 4.2、Go

#### 1、泛型数据结构

泛型数据结构单独使用意义不是很大，发挥他们作用的主要是在函数、方法的参数或返回值中使用这些泛型结构，将会给编程带来极大的便利。减少大家再运行时对类型的判断。

```go
func main() {
	// 1、泛型切片：可以使用int float32 float64类型实例化
	type Slice[T int | float32 | float64] []T

	var a Slice[int] = []int{1, 2, 3, 4}
	fmt.Printf("Type: %T", a)

	// 2、泛型map，可以使用int string实例化key，float32 float64 string int实例化value
	type Map[K int | string, V float32 | float64 | string | int] map[K]V

	// 3、泛型结构体。可用 int 或 sring 类型实例化
	type MyStruct[T int | string] struct {
		Name string
		Data T
	}

	// 4、泛型接口：(关于泛型接口在后半部分会详细讲解）
	type IPrintData[T int | float32 | string] interface {
		Print(data T)
	}

	// 5、泛型通道：可用类型实参 int 或 string 实例化
	type MyChan[T int | string] chan T
}
```



#### 2、泛型函数

```go
func main() {
	var result int = Add[int](1, 2) // 传入类型实参int，计算结果为 3
	fmt.Println(result)

	var fResult float32 = Add[float32](1.0, 2.0) // 传入类型实参float32, 计算结果为 3.0
	fmt.Println(fResult)

	// 或许你会觉得这样每次都要手动指定类型实参太不方便了。所以Go还支持类型实参的自动推导：
	result = Add(1, 2) // 1，2是int类型，编译请自动推导出类型实参T是int
	fmt.Println(result)
	var f64Result float64 = Add(1.0, 2.0) // 1.0, 2.0 是浮点，编译请自动推导出类型实参T是float32
	fmt.Println(f64Result)

	//Add[string]("hello", "world") // 错误。因为泛型函数Add的类型约束中并不包含string
}
func Add[T int | float32 | float64](a T, b T) T {
	return a + b
}
```



#### 3、泛型类接口（接收器Receiver）

通过泛型receiver，泛型的实用性一下子得到了巨大的扩展。在没有泛型之前如果想实现通用的数据结构，诸如：堆、栈、队列、链表之类的话，我们的选择只有两个：

- 为每种类型写一个实现
- 使用 接口+反射

而有了泛型之后，我们就能非常简单地创建通用数据结构了。

```go
// 定义类型
type MySlice[T int | float32] []T

// 定义类型上的方法
func (s MySlice[T]) Sum() T {
	var sum T
	for _, value := range s {
		sum += value
	}
	return sum
}


```



## 参考：

Java泛型

- 深入理解Java泛型： https://dunwu.github.io/blog/pages/33a820/
- Java泛型的上下边界：https://www.jianshu.com/p/00d50c1e46a9
- **Java泛型的上下边界**：https://segmentfault.com/a/1190000041803282
- 向上/向下转型：https://blog.csdn.net/jim__charles/article/details/52671480
- 向上/向下转型：https://zhuanlan.zhihu.com/p/34026164

Go泛型

- Go1.18泛型全面讲解： https://segmentfault.com/a/1190000041634906

# 单元测试

# 汇编基础知识

## 1、ATT与Intel汇编代码格式

### 1.1、寄存器名

AT&T 中寄存器名要加前缀`%`，而 Intel 则不需要。例如：

```assembly
pushl %eax # AT&T 格式
push eax # Intel 格式
```

### 1.2、立即操作数

AT&T 中用`$`前缀表示一个立即数，而 Intel 不用带任何前缀。例如：

```asm
pushl $1 # AT&T
push 1 # Intel
```

### 1.3、操作方向

AT&T 与 Intel 中的源操作数和目标操作数的位置正好相反。

AT&T 目标操作数在源操作数的右边，Intel 目标操作数在源操作数的左边。例如：

```asm
addl $1,%eax # AT&T
add eax,1 # Intel
```

### 1.4、操作字长

AT&T 操作数的字长由操作数的最后一个字母决定，后缀以及表示字长如下：

- `b`：byte，单字节，8 比特（bit）
- `w`：word，字(双字节)16比特
- `l`：long，双字，32比特
- q  ：quad word，四字，64比特

Intel 操作数的字长用`byte ptr`和`word ptr`等指令前缀来表示。例如：

```asm
movb val,%al # AT&T
movl al,byte ptr val # Intel
```

### 1.5、绝对转移和调用

AT&T 绝对转移`jump`和调用`call`的操作数要加入`*`前缀，而 Intel 则不需要

### 1.6、远程转移和远程子调用

AT&T 远程转移指令`ljump`和远程子调用指令`lcall`，而 Intel 则为`jmp far`和`call far`

```asm
ljump $section,$offset # AT&T
lcall $section,$offset

jmp far section:offset # Intel
call far section:offset
```

### 1.7、相对应的远程返回

```asm
lret $stack_adjust # AT&T
ret far stack_adjust # Intel
```

### 1.8、内存操作数的寻址方式

AT&T 的格式为`section:disp(base,index,scale)`，而 Intel 为`section:[base + index*scale + disp]`

下面是一些内存操作数的例子：

```asm
# AT&T 
movl -4(%ebp),%eax
movl array(,%eax,4),%eax
movw array(%ebx,%eax,4),%cx
movb $4,%fs:(%eax)

# Intel
mov eax,[ebp - 4]
mov eax,[eax*4 + array]
mov cx,[ebx + 4*eax + array]
mov fs:eax,4
```

## 2、寄存器

### 2.1、寄存器分类

- **程序计数器**：通常称为PC，在x86-64中用%rip表示，给出要执行的下一条指令在内存中的地址。
- **整数寄存器**：包含16个命名的位置，分别存储64位的值。这些寄存器可以存储地址(对应C语言的指针)或整数数据。有的寄存器用来记录某些重要的程序状态，而其它的寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值。
- **条件码寄存器**：保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化，比如说用来实现if和while语句。
- **向量寄存器**：可以存放一个或多个整数或浮点数。

### 2.2、整数寄存器

如下图解释说明的那样，在常见的程序里不同的寄存器扮演不同的角色。其中最特别的是栈指针%rsp，用来指明运行时栈的结束位置。有些指令会明确的写这个寄存器。

另外15个寄存器的用法更加灵活。少量指令会使用某些特定的寄存器。更重要的是，有一组标准的编程规范控制着如何使用寄存器来管理栈、传递函数参数、从函数的返回值，以及存储局部和临时数据。

![x86-64 16个通用寄存器](/Users/skwqy/Documents/doc/LangueStudy/image/common/x86-64 16个通用寄存器.png)

**说明：**

1. 64位有16个寄存器，32位只有8个。但是32位前8个都有不同的命名，分别是e _ ，而64位前8个使用了r代替e，也就是r _。e开头的寄存器命名依然可以直接运用于相应寄存器的低32位。而剩下的寄存器名则是从r8 - r15，其低位分别用d，w,b指定长度。
2. 32位使用栈帧来作为传递的参数的保存位置，而64位使用寄存器，分别用rdi,rsi,rdx,rcx,r8,r9作为第1-6个参数。rax作为返回值
3. 64位没有栈帧的指针，32位用ebp作为栈帧指针，64位取消了这个设定，rbp作为通用寄存器使用
4. 64位支持一些形式的以PC相关的寻址，而32位只有在jmp的时候才会用到这种寻址方式。

## 3、操作数指示符

大多数的指令都有一个或多个操作数，指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。源数据值可以以常数形式给出，或是从寄存器或内存中读出。结果可以存放在寄存器或内存中。因此各种不同的操作数的可能性被分为三种类型：

- 立即数：用来表示常数值。在ATT格式的汇编代码中，立即数的书写方式是'\$'后面跟标准C表示法表示的整数。（比如\$577、$0x1F）。不同的指令允许的立即数范围不同，汇编器会自动选择最紧凑的方式进行数值编码。
- 寄存器：它表示某个寄存器的内容，16个寄存器的低位1字节、2字节、4字节或8字节中的一个作为操作数，这些字节数分别对应8位、16位、32位或64位。我们用ra来表示任意寄存器a，用引用R[ra]来表示它的值，这是将寄存器集合看成一个数组R，用寄存器标识符作为索引。
- 内存引用：它会根据计算出来的地址（通常称为有效地址）访问某个内存位置。因为将内存看成一个很大的字节数组，我们用符号M[Addr]表示对存储在内存中从地址Addr开始的b个字节的引用。

### 3.1、操作数格式

| 类型   | 格式           | 操作数值                   | 名称                                             |
| ------ | -------------- | -------------------------- | ------------------------------------------------ |
| 立即数 | $Imm           | Imm                        | 立即数寻址                                       |
| 寄存器 | ra             | R[ra]                      | 寄存器寻址                                       |
| 存储器 | Imm            | M[Imm]                     | 绝对寻址                                         |
| 存储器 | (ra)           | M[R[ra]]                   | 间接寻址：根据寄存器中的值，来确定访问内存的位置 |
| 存储器 | Imm(rb)        | M[Imm + R[rb]]             | (基址+偏移量)寻址                                |
| 存储器 | (rb, ri)       | M[R[rb] + R[ri]]           | 变址寻址                                         |
| 存储器 | Imm(rb, ri)    | M[Imm + R[rb] + R[ri]]     | 变址寻址                                         |
| 存储器 | (, ri, s)      | M[R[ri] * s]               | 比例变址寻址                                     |
| 存储器 | Imm(, ri, s)   | M[Imm + R[ri] * s]         | 比例变址寻址                                     |
| 存储器 | (rb, ri, s)    | M[R[rb] + R[ri] * s]       | 比例变址寻址                                     |
| 存储器 | Imm(rb, ri, s) | M[Imm + R[rb] + R[ri] * s] | 比例变址寻址                                     |

说明：

- Imm(rb, ri, s)表示是最常用的形式。它有四部分组成：一个立即数偏移Imm，一个基址寄存器rb、一个变址寄存器ri和一个比例因子s。比例因子s必须是1、2、4、或者8
- 引用数组元素时，会用到这种通用形式。其它形式都是这种通用形式的特殊情况。

## 4、汇编指令

### 4.1、数据传送指令

数据传送指令-MOV类：这些指令把数据从源位置复制到目的位置。

1. 源操作数（**S**）指定的值是一个立即数（**I**），存储在寄存器或内存中（**Imm(rb, ri, s)及其变形**）。
2. 目的操作数（**D**）指定一个位置：要么是一个寄存器（**R**），要么是一个内存地址。
3. X86-64加了一条限制，传送指令的两个操作数不能都指向内存位置。
   - 将一个值从一个内存位置复制到另一个内存位置需要两条指令：第一条指令将源值加载到寄存器中，第二条将该寄存器值写入目的内存的位置。
4. MOV指令只会更新目的操作数指定的那些寄存器字节或内存位置。唯一例外的是movl指令以寄存器作为目的时，他会把该寄存器的高位4字节设置为0.

#### 4.1.1、简单数据传送指令

| 指令          | 效果    | 描述                    |
| ------------- | ------- | ----------------------- |
| MOV   S, D    | D <-- S | 传送                    |
| movb          |         | 传送字节（8bit）        |
| movw          |         | 传送字（16bit）         |
| movl          |         | 传送双字（32bit）       |
| movq          |         | 传送四字（64bit）       |
| movabsq  I, R | R <-- I | 传送绝对的四字（64bit） |

**注意：**

- movq：指令只能以表示为32位补码数字的立即数作为源操作数，然后把这个值符号扩展得到64位的值，放到目的位置。
- movabsq：指令能够以任意64位立即数值作为源操作数，并且只能以寄存器作为目的。

#### 4.1.2、零扩展数据传送指令

使用场景：将较小的源值复制到较大的目的时使用。

- 所有的这些指令（MOVZ、MOVS）都是把数据从源（在**寄存器或内存**中）复制到目的**寄存器**。
- MOVZ类中的指令把目的中剩余的字节填充为0，而MOVS类中的指令通过符号扩展来填充，把源操作数的最高位进行复制。
- 每条指令名字的最后两个字符都是大小指示符：第一个字符指定源的大小，第二个指明目的的大小。

| 指令        | 效果            | 描述                         |
| ----------- | --------------- | ---------------------------- |
| MOVZ  S,  R | R <-- 零扩展(S) | 以零扩展进行传送             |
| movzbw      |                 | 将做了零扩展的字节传送到字   |
| movzbl      |                 | 将做了零扩展的字节传送到双字 |
| movzbq      |                 | 将做了零扩展的字节传送到四字 |
| movzwl      |                 | 将做了零扩展的字传送到双字   |
| movzwq      |                 | 将做了零扩展的字传送到四字   |

**说明：**

- movzbl、movzwl同movl指令的效果一样，也会将目的寄存器高4字节置为0

#### 4.1.3、符号扩展数据传送指令

| 指令        | 效果                    | 描述                             |
| ----------- | ----------------------- | -------------------------------- |
| MOVS  S,  R | R <-- 符号扩展(S)       | 以符号扩展进行传送               |
| movsbw      |                         | 将做了符号位扩展的字节传送到字   |
| movsbl      |                         | 将做了符号位扩展的字节传送到双字 |
| movsbq      |                         | 将做了符号位扩展的字节传送到四字 |
| movswl      |                         | 将做了符号位扩展的字传送到双字   |
| movswq      |                         | 将做了符号位扩展的字传送到四字   |
| movslq      |                         | 将做了符号位扩展的双字传送到四字 |
| cltq        | %rax <-- 符号扩展(%eax) | 把%eax符号扩展到%rax             |

**说明：**

- cltq指令只作用于寄存器%eax和%rax

  

### 4.2、栈操作指令

1. 栈是一种数据结构，可添加或者删除值，不过要遵循“后进先出”的原则。
2. 通过push操作把数据压入栈中，通过pop操作删除数据。弹出的值永远是最近被压入而且仍然在栈中的值。
3. 栈可以实现为一个数组，总是从数组的一端插入和删除元素，这一端被称为栈顶。
4. 在x86-64中，程序栈存放在**内存中某个区域**。

| 指令     | 效果                                       | 描述         |
| -------- | ------------------------------------------ | ------------ |
| pushq  S | R[%rsp] <-- R[%rsp]-8;<br>M[R[%rsp]] <-- S | 将四字压入栈 |
| popq  D  | D <-- M[R[%rsp]];<br>R[%rsp] <-- R[%rsp]+8 | 将四字弹出栈 |

说明：

1. 将一个四字值压入栈中，首先要将栈指针减8，然后后将值写道新的栈顶地址。因此指令push %rbp的行为等价于下面两条指令：

   subq	$8, %rsp

   movq	%rbp, (%rsp)

   它们之间的区别是在机器代码中qushq指令编码为1字节，而上面那两条指令一共需要8个字节。

2. 弹出一个四字的操作包括从栈顶位置读出数据，然后将栈指针加8.因此，指令popq %rax等价于下面两条指令：

   movq	(%rsp), %rax

   addq	$8, %rsp

![x86-64栈操作](./image/common/x86-64栈操作.jpeg)

### 4.3、算术与逻辑操作指令

#### 4.3.1、常规算术与逻辑指令

大多数操作都分层了指令类，这些指令类有各种不同大小操作数的变种（只有leaq没有其他大小的变种）。例如指令类ADD由四条加法指令组成：addb、addw、addl、addq，分别是字节加法、字加法、双字加法和四字加法。

| 指令          | 效果          | 描述              |
| ------------- | ------------- | ----------------- |
| leaq    S,  D | D <-- &S      | 加载有效地址      |
|               |               |                   |
| INC     D     | D <-- D+1     | 加1               |
| DEC    D      | D <-- D-1     | 减1               |
| NEG    D      | D <-- -D      | 取负              |
| NOT    D      | D <-- ~D      | 取补              |
|               |               |                   |
| ADD    S,  D  | D <-- D + S   | 加                |
| SUB    S,  D  | D <-- D - S   | 减                |
| IMUL   S,  D  | D <-- D * S   | 乘                |
| XOR    S,  D  | D <-- D ^ S   | 异或              |
| OR      S,  D | D <-- D \| S  | 或                |
| AND    S,  D  | D <-- D & S   | 与                |
|               |               |                   |
| SAL     k,  D | D <-- D << k  | 左移              |
| SHL     k,  D | D <-- D << k  | 左移（等同于SAL） |
| SAR     k,  D | D <-- D >>A k | 算术右移          |
| SHR     k,  D | D <-- D >>L k | 逻辑右移          |

说明：

1. leaq指令实际上是movq的变形。它的指令形式是从内存读取数据到寄存器，但实际上它根本没有引用内存。它的第一个操作数看上去是一个内存引用，但该指令并不是从指定的位置读取数据，而是将有效地址写入到目的操作数。**目的操作数必须是一个寄存器**。
2. ATT格式的汇编代码中，操作数的顺序与一般直觉相反。例如：SUB S,D 的结果是D <-- D - S

#### 4.3.2、特殊的算术指令

![x86-64特殊算术操作指令](./image/common/x86-64特殊算术操作指令.jpeg)

### 4.4、控制指令

#### 4.4.1、条件码

除了整数寄存器，CPU还维护做一组单个位的条件码（condition code）寄存器，他们描述了最近的算术或逻辑操作的属性。可以检测这些寄存器来执行条件分支指令。

最常用的条件码有：

1. CF：进位标志。最近的操作使最高位产生了进位。可用来检查无符号操作的溢出。
2. ZF：零标志。最近的操作得出的结果位0.
3. SF：符号标志。最近的操作得到的结果位负数。
4. OF：溢出标志。最近的操作导致一个补码溢出：正溢出或负溢出。

#### 4.4.1、比较和测试指令

这些指令不修改任何寄存器的值，只设置条件码。

![x86-64比较测试指令](./image/common/x86-64比较测试指令.png)

#### 4.4.2、访问条件码

![x86-64SET指令](./image/common/x86-64SET指令.png)

说明：

- none: 非
- equal：等于
- greater：大于
- less：小于

#### 4.4.3、跳转指令

![x86-64跳转指令](./image/common/x86-64跳转指令.png)

#### 4.4.4、条件传送指令

![x86-64条件传送指令](./image/common/x86-64条件传送指令.png)

### 4.5、控制转移指令

![x86-64控制转义指令](./image/common/x86-64控制转义指令.png)

## 5、典型的汇编代码

### 5.1、条件分支

#### 5.1.1、条件控制来实现条件分支

![条件语句的编译](./image/common/x86汇编/条件语句的编译.png)

说明：

1. 调用absdiff_se函数的调用者已经将参数x、y分别存放到寄存器%rdi、%rsi中。
2. %rip：pc寄存器，给出要执行的下一条指令在内存中的地址

#### 5.1.2、条件传送来实现条件分支

![条件传送实现条件分支](./image/common/x86汇编/条件传送实现条件分支.png)

说明：

- 条件传送指令：cmovge S, R表示当条件满足时，指令把源值S复制到目的R。
- cmpq：比较x、y，并设置对应的条件码寄存器。
- cmovge：根据条件码寄存器中的flag，判断如果符合 >= 条件时，将源值S复制到目的R。

### 5.2、循环语句

#### 5.2.1、do-while循环

![dowhile循环](./image/common/x86汇编/dowhile循环.png)

说明：

- %rdi：存放函数参数n

#### 5.2.2、while循环

![while循环](./image/common/x86汇编/while循环.png)

#### 5.2.3、while循环2

![while循环2-1](./image/common/x86汇编/while循环2-1.png)

![while循环2-2](./image/common/x86汇编/while循环2-2.png)

### 5.3、switch语句

![switch-1](./image/common/x86汇编/switch-1.png)

![switch-2](./image/common/x86汇编/switch-2.png)

说明：

- 函数参数：x：%rdi、n：%rsi、*dest：%rdx

### 5.4、函数调用

#### 5.4.1、运行时栈

![运行时栈-1](./image/common/x86汇编/运行时栈-1.png)

![运行时栈-2](./image/common/x86汇编/运行时栈-2.png)

#### 5.4.2、调用&返回

![转移控制-1](./image/common/x86汇编/转移控制-1.png)

![转移控制-2](./image/common/x86汇编/转移控制-2.png)

#### 5.4.3、数据传送

​     当调用一个过程时，除了要把控制传递给它并在过程返回时再传递回来之外，过程调用还可能把数据作为参数传递，而从过程返回还有可能包括返回一个值。X86-64中，大部分过程间的数据传递都是通过寄存器实现的。

​    X86-64中，可以通过寄存器最多传递6个整形（即整数和指针）。寄存器的使用是有特殊顺序的，寄存器使用的名字取决于要传递的数据类型的大小。如下图所示：

![传递函数参数的寄存器](./image/common/x86汇编/传递函数参数的寄存器.png)

如果一个函数有大于6个整形参数，超出6个的部分就要通过栈来传递：要把1~6复制到对应的寄存器，把参数7~n放到栈上，**而参数7位于栈顶**。通过栈传递参数时，**所有的数据大小都向8的倍数对**齐。

返回值通过寄存器%rax返回

![函数参数传递-示例](./image/common/x86汇编/函数参数传递-示例.png)

![函数参数传递-示例2](./image/common/x86汇编/函数参数传递-示例2.png)

#### 5.4.4、栈上的局部存储

![栈上的局部存储](./image/common/x86汇编/栈上的局部存储.png)

![栈上的局部存储-示例1](./image/common/x86汇编/栈上的局部存储-示例1.png)

![栈上的局部存储-示例2](./image/common/x86汇编/栈上的局部存储-示例2.png)

![栈上的局部存储-示例3](./image/common/x86汇编/栈上的局部存储-示例3.png)

#### 5.4.5、寄存器中的局部存储空间

​     寄存器组是唯一被所有过程共享的资源。虽然在给定时刻只有一个过程是活动的，我们仍然必须确保当一个过程（调用者）调用另一个过程（被调用者）时，被调用者不会覆盖调用者稍后会使用的寄存器值。为此x86-64采用了一组统一的寄存器使用惯例，所有的过程（包括程序库）都必须遵循。

1. 被调用者保存寄存器：%rbx、%rbp、%r12~%r15.

   当过程P调用过程Q时，Q必须保存这些寄存器的值，保证它们的值在Q返回到P时与Q被调用时是一样的。

   过程Q保持一个寄存器的值不变，要么是根本不去改变它，要么就是把原始值入栈，使用该寄存器，然后在返回前从栈中弹出旧值。

2. 调用者保存寄存器：除了被调用者保存寄存器和%rsp。传递参数的寄存器都属于调用者保存寄存器。

   任何函数都能随意修改它们

![寄存器中局部存储-示例](./image/common/x86汇编/寄存器中局部存储-示例.png)

### 5.5、递归过程

![递归过程-示例](./image/common/x86汇编/递归过程-示例.png)

# Java字节码指令

参考： 

- https://bbs.huaweicloud.com/blogs/267397
- https://www.cnblogs.com/qing-gee/p/15089339.html

## 1、操作码助记符

| 操作码助记符 | 数据类型 |
| :----------: | :------: |
|      b       |   byte   |
|      c       |   char   |
|      s       |  short   |
|      i       |   int    |
|      l       |   long   |
|      f       |  float   |
|      d       |  double  |
|      a       | 引用类型 |

## 2、字节码指令

### 2.1、加载和存储指令

加载（load）和存储（store）指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输：

![加载存储栈示例](./image/java/JVM/加载存储栈示例.png)

#### 2.1.1、局部变量加载到栈

Xload_N

| 指令     | 参数说明                             | 描述                                                         |
| -------- | ------------------------------------ | ------------------------------------------------------------ |
| Xload_N  | X：i、l、f、d、a<br>N：0、1、2、3    | 表示将第N个局部变量压入操作数栈中                            |
| Xload  S | X：i、l、f、d、a<br>S：指令参数，8位 | 通过参数指定索引，将局部变量表中索引为S的X类型数据压入操作数栈中<br>当使用这个指令时表示局部变量的数量可能超过4个 |

#### 2.1.2、常量加载到栈

| 指令        | 参数说明                            | 描述                                                         |
| ----------- | ----------------------------------- | ------------------------------------------------------------ |
| Xconst_N    | X：i、l、f、d<br/>N：-1、0、1、2、3 | 将常量N作为X类型的入栈                                       |
| aconst_null |                                     | 将null入栈                                                   |
| Xipush  S   | X：b、s<br>S：指令参数              | 将单字节或双字节的参数S入栈，入栈后当做int类型               |
| ldc  S      | S：指令参数，8位                    | 当 const 和 push 不能满足的时候，使用Idc 指令；<br>它接收一个 8 位的参数，指向常量池中的索引。<br>能处理int、float、String类型的数据 |
| ldc_w  S    | S：指令参数，16位                   | 同上，只不过能索引的常量池范围扩大了                         |
| Ldc2_w  S   | S：指令参数，16位                   | 功能同上，处理的类型变为：long、double                       |

#### 2.1.3、操作数栈存储到局部变量表

| 指令      | 参数说明                           | 描述                                           |
| --------- | ---------------------------------- | ---------------------------------------------- |
| Xstore_N  | X：i、l、f、d、a<br/>N：0、1、2、3 | 将栈上类型为X的数据存储到索引为N的局部变量表中 |
| Xstore  S | S：指令参数，8位i                  | 将栈上类型为X的数据存储到索引为S的局部变量表中 |

#### 2.1.4、数组加载指令

| 指令   | 说明                                                         |
| ------ | ------------------------------------------------------------ |
| Xaload | X:i、l、f、d、a、b(bool或byte)、c、s；将X型数组指定索引的值推送到栈顶 |

#### 2.1.5、数组存储指令

| 指令    | 说明                                                         |
| ------- | ------------------------------------------------------------ |
| Xastore | X:i、l、f、d、a、b(bool或byte)、c、s；将栈顶X型数值存入指定数组的指定索引位置 |

### 2.2、栈管理指令

| 指令      | 参数说明 | 描述                                                         |
| --------- | -------- | ------------------------------------------------------------ |
| pop       |          | 将从栈顶数值(非long、double)弹出，并且直接废弃。             |
| pop2      |          | 将栈顶一个(long、double)或两个(非long、double)数值弹出。     |
| dup       |          | 复制栈顶数值(非long、double)并将复制值压入栈顶。             |
| dup2      |          | 复制栈顶一个(long、double)或两个(非long、double)             |
| dup_x1    |          | 复制栈顶数值(非long、double)，并将两个复制值压入栈顶。       |
| dup2_x1   |          | 复制栈顶数值(long、double)，并将两个复制值压入栈顶。         |
| dup_×2    |          | 复制栈顶数值(非long、double)，并将三个(或两个)复制值压入栈顶。 |
| *dup2*_×2 |          | 复制栈顶数值(long、double)，并将三个(或两个)复制值压入栈顶。 |
| swap      |          | 将栈最顶端的两个槽中的数值交换位置                           |

### 2.3、运算指令

算术指令用于**对两个操作数栈上的值**进行某种特定运算，并**把结果重新存入到操作栈顶**。大体上运算指令可以分为两种：对整型数据进行运算的指令与对浮点型数据进行运算的指令。

| 指令              | 参数说明                                   | 描述                                                         |
| ----------------- | ------------------------------------------ | ------------------------------------------------------------ |
| Xadd              | X：i、l、f、d                              | 加法指令                                                     |
| Xsub              | X：i、l、f、d                              | 减法指令                                                     |
| Xmul              | X：i、l、f、d                              | 乘法指令                                                     |
| Xdiv              | X：i、l、f、d                              | 除法指令                                                     |
| Xrem              | X：i、l、f、d                              | 取余指令                                                     |
| Xneg              | X：i、l、f、d                              | 取反指令                                                     |
|                   |                                            |                                                              |
| ishl、lshl        |                                            | 将int、long类型值左移位指定位数，并将结果压入栈顶            |
| ishr、lshr        |                                            | 将int、long类型值右（符号）移位指定位数，并将结果压入栈顶    |
| iushr、lushr      |                                            | 将int、long类型值右（无符号）移位指定位数，并将结果压入栈顶  |
| iand、land        |                                            | 按位与指令                                                   |
| ior、lor          |                                            | 按位或指令                                                   |
| ixor、lxor        |                                            | 按位异或指令                                                 |
| iinc   INDEX, NUM | INDEX：本地变量的编号<br>NUM：自增减的数量 | 局部变量自增指令                                             |
|                   |                                            |                                                              |
| lcmp              |                                            | 比较栈顶两long型数值大小，并将结果(1,0,-1)压入栈顶           |
| Xcmpg             | X：f、d                                    | 比较栈顶两个float、double型数值大小，并将结果(1,0,-1)压入栈顶；当其中一个数值为NaN时，将1压入栈顶 |
| Xcmpl             | X：f、d                                    | 比较栈顶两个float、double型数值大小，并将结果(1,0,-1)压入栈顶；当其中一个数值为NaN时，将-1压入栈顶 |

自增减指令 iinc 说明：

- 该指令用于对本地（局部）变量进行自增减操作。
- 该指令的第一个参数为：本地变量的编号，第二个参数为：自增减的数量。

### 2.4、控制转移指令

控制转移指令可以让Java虚拟机有条件或无条件地从指定位置指令（而不是控制转移指令）的下一条指令继续执行程序，从概念模型上理解，可以认为控制指令就是在有条件或无条件地修改PC寄存器的值。

#### 2.4.1、有条件跳转指令

该系列指令用于对栈顶int型元素进行比较，根据结果进行跳转。第一个参数为要跳转到的代码地址（这里的地址是指其指令在函数内是第几个指令）。注意对于boolean型，其实是把它当做int型来处理的。另外对于引用比较使用时，其实是对存储的对象的地址进行比较。

| 指令      | 说明                                         |
| --------- | -------------------------------------------- |
| ifeq      | 当栈顶int型数值 =0 时跳转                    |
| ifne      | 当栈顶int型数值 !=0 时跳转                   |
| iflt      | 当栈顶int型数值 <0 时跳转                    |
| ifgt      | 当栈顶int型数值 >0 时跳转                    |
| ifge      | 当栈顶int型数值 >=0 时跳转                   |
| ifle      | 当栈顶int型数值 <=0 时跳转                   |
| if_icmpeq | 比较栈顶两int型数值大小，当结果 =0 时跳转    |
| if_icmpne | 比较栈顶两int型数值大小，当结果 !=0 时跳转   |
| if_icmplt | 比较栈顶两int型数值大小，当结果 <0 时跳转    |
| if_icmpgt | 比较栈顶两int型数值大小，当结果 >0 时跳转    |
| if_icmple | 比较栈顶两int型数值大小，当结果 <=0 时跳转   |
| if_icmpgt | 比较栈顶两int型数值大小，当结果 >=0 时跳转   |
| if_acmpeq | 比较栈顶两引用型数值大小，当结果相等时跳转   |
| if_acmpne | 比较栈顶两引用型数值大小，当结果不相等时跳转 |
| ifnull    | 为null时跳转                                 |
| ifnotnull | 不为null时跳转                               |

#### 2.4.2、无条件跳转指令

| 指令         | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| goto         | 无条件跳转                                                   |
| goto_w       | 无条件跳转（宽索引）                                         |
| jsr          | 跳转至指定16位offset位置，并将jsr下一条指令地址压入栈顶      |
| jsr_w        | 跳转至指定32位offset位置，并将jsr_w下一条指令地址压入栈顶    |
| ret          | 返回至本地变量指定的index的指令位置（一般与jsr、jsr_w联合使用） |
| tableswitch  | 用于switch条件跳转，case值连续（可变长度指令）               |
| lookupswitch | 用于switch条件跳转，case值不连续（可变长度指令）             |

2

### 2.5、类型转换指令

#### 2.5.1、宽化

宽化，小类型向大类型转换，比如 `int–>long–>float–>double`，对应的指令有：i2l、i2f、i2d、l2f、l2d、f2d。

- 从 int 到 long，或者从 int 到 double，是不会有精度丢失的；

- 从 int、long 到 float，或者 long 到 double 时，可能会发生精度丢失；

- 从 byte、char 和 short 到 int 的宽化类型转换实际上是隐式发生的，这样可以减少字节码指令，毕竟字节码指令只有 256 个，占一个字节。

  

| 指令          | 说明                         |
| ------------- | ---------------------------- |
| i2l、i2f、i2d | int转换为long、float、double |
| l2f、l2d      | long转换为float、double      |
| f2d           | float转换为double            |

#### 2.5.2、窄化

窄化，大类型向小类型转换

- 窄化很可能会发生精度丢失，毕竟是不同的数量级；
- 但 Java 虚拟机并不会因此抛出运行时异常。

| 指令          | 说明                              |
| ------------- | --------------------------------- |
| i2b、i2s、i2c | int 类型到 byte、short 或者 char  |
| l2i           | 从 long 到 int                    |
| f2i、f2l      | 从 float 到 int 或者 long         |
| d2i、d2l、d2f | 从 double 到 int、long 或者 float |



### 2.6、对象创建&访问&操作

#### 2.6.1、对象创建

| 指令           | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| new            | 创建一个对象，并将其引用值压入栈顶                           |
| newarray       | 创建一个指定原始类型（如int、float、char...）的数组，并将其引用值压入栈顶 |
| anewarray      | 创建一个引用类型（如类、接口、数组）的数组，并将其引用压入栈顶 |
| multianewarray | 创建指定类型和指定维度的多维数组（执行该指令时，操作数栈中必须包含各维度的长度值），并将其引用值压入栈顶 |

#### 2.6.2、对象访问

| 指令      | 说明                                 |
| --------- | ------------------------------------ |
| getstatic | 获取指定类的静态域，并将其值压入栈顶 |
| putstatic | 用栈顶的值为指定的类的静态域赋值     |
| getfield  | 获取指定类的实例域，并将其值压入栈顶 |
| putfield  | 用栈顶的值为指定的类的实例域赋值     |

#### 2.6.3、对象操作

| 指令        | 说明                                                         |
| ----------- | ------------------------------------------------------------ |
| checkcast   | 检验类型转换，检验未通过将抛出ClassCastException             |
| instanceof  | 检验对象是否是指定的类的实例，如果是将1压入栈顶，否则将0压入栈顶 |
| arraylength | 获得数组的长度值并压入栈顶                                   |

### 2.7、方法调用&返回指令

| 指令            | 说明                                                         |
| --------------- | ------------------------------------------------------------ |
| invokevirtual   | 调用实例方法（虚方法）                                       |
| invokeinterface | 调用接口方法                                                 |
| invokespecial   | 需要特殊处理的实例方法。比如初始化方法、私有方法、父类方法。 |
| invokestatic    | 调用静态方法                                                 |
| invokedynamic   | 用于在运行时动态解析出调用点限定符所引用的方法。并执行该方法。前面四条调用指令的分派逻辑都固化在Java虚拟机内部，用户无法改变，而invokedynamic指令的分派逻辑 是由用户所设定的引导方法决 |
| ireturn         | 当返回值是boolean、byte、char、short和int类型时使用          |
| Xreturn         | X:l、f、d、a，当返回值是long、float、double、引用类型时使用。 |
| return          | 当返回值为void时使用。                                       |



### 2.8、异常处理指令



### 2.9、同步指令

| 指令         | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| monitorenter | 获取对象的锁，用于同步方法或同步块。用来支持synchronized关键字的语义。 |
| monitorexit  | 释放对象的锁，用于同步方法或同步块。                         |

## Go汇编语言：

参考：https://chai2010.gitbooks.io/advanced-go-programming-book/content/ch3-asm/readme.html

## 1、变量定义：

### 1.1、定义整形变量（值类型）

#### 1.1.1、变量初始化

Go汇编语言提供了DATA命令用于初始化包变量，DATA命令的语法如下：

```asm
DATA symbol+offset(SB)/width, value
```

- symbol：为变量在汇编语言中对应的标识符
- offset：是符号开始地址的偏移量
- width：是要初始化内存的宽度大小
- value：是要初始化的值

其中当前包中Go语言定义的符号symbol，在汇编代码中对应`·symbol`，其中“·”中点符号为一个特殊的unicode符号。

#### 1.1.2、变量导出

变量定义好之后需要导出以供其它代码引用。Go汇编语言提供了GLOBL命令用于将符号导出：

```asm
GLOBL symbol(SB), width
```

- symbol：对应汇编中符号的名字
- width：为符号对应内存的大小

#### 1.1.3、举例

```go
package pkg

var Id int = 9527
```

给Id变量初始化为十六进制的0x2537，对应十进制的9527（常量需要以美元符号$开头表示）

```asm
GLOBL ·Id(SB),$8

DATA ·Id+0(SB)/1,$0x37
DATA ·Id+1(SB)/1,$0x25
DATA ·Id+2(SB)/1,$0x00
DATA ·Id+3(SB)/1,$0x00
DATA ·Id+4(SB)/1,$0x00
DATA ·Id+5(SB)/1,$0x00
DATA ·Id+6(SB)/1,$0x00
DATA ·Id+7(SB)/1,$0x00
```

### 1.2、定义字符串变量（引用类型）

#### 1.2.1、字符串定义分析

```go
package pkg

var Name = "gopher"
```

Go编译器编译后的汇编片段如下：

```asm
go tool compile -S string_asm.go

go.string."gopher" SRODATA dupok size=6
        0x0000 67 6f 70 68 65 72                                gopher
"".Name SDATA size=16
        0x0000 00 00 00 00 00 00 00 00 06 00 00 00 00 00 00 00  ................
        rel 0+8 t=1 go.string."gopher"+0
```

输出中出现了一个新的符号go.string."gopher"，根据其长度和内容分析可以猜测是对应底层的"gopher"字符串数据。因为Go语言的字符串并不是值类型，Go字符串其实是一种只读的引用类型。如果多个代码中出现了相同的"gopher"只读字符串时，程序链接后可以引用的同一个符号go.string."gopher"。因此，该符号有一个SRODATA标志表示这个数据在只读内存段，dupok表示出现多个相同标识符的数据时只保留一个就可以了。

而真正的Go字符串变量Name对应的大小却只有16个字节了。其实Name变量并没有直接对应“gopher”字符串，而是对应16字节大小的reflect.StringHeader结构体：

```go
type reflect.StringHeader struct {
    Data uintptr
    Len  int
}
```

从汇编角度看，Name变量其实对应的是reflect.StringHeader结构体类型。前8个字节对应底层真实字符串数据的指针，也就是符号go.string."gopher"对应的地址。后8个字节对应底层真实字符串数据的有效长度，这里是6个字节。

```asm
"".Name SDATA size=16
        0x0000 00 00 00 00 00 00 00 00 06 00 00 00 00 00 00 00  ................
        // 00 00 00 00 00 00 00 00  
        // 前8个字节对应底层真实字符串数据的指针，也就是符号go.string."gopher"对应的地址
        // 06 00 00 00 00 00 00 00 
        // 后8个字节对应底层真实字符串数据的有效长度，这里是6个字节。
```

#### 1.2.2、汇编尝试1

尝试通过汇编代码重新定义并初始化Name字符串：

```asm
GLOBL ·NameData(SB),$8
DATA  ·NameData(SB)/8,$"gopher"

GLOBL ·Name(SB),$16
DATA  ·Name+0(SB)/8,$·NameData(SB)
DATA  ·Name+8(SB)/8,$6
```

因为在Go汇编语言中，go.string."gopher"不是一个合法的符号，因此我们无法通过手工创建（这是给编译器保留的部分特权，因为手工创建类似符号可能打破编译器输出代码的某些规则）。**因此我们新创建了一个·NameData符号表示底层的字符串数据。**然后定义·Name符号内存大小为16字节，其中前8个字节用·NameData符号对应的地址初始化，后8个字节为常量6表示字符串长度。

当用汇编定义好字符串变量并导出之后，还需要在Go语言中声明该字符串变量。然后就可以用Go语言代码测试Name变量了：

```go
package main

import pkg "path/to/pkg"

func main() {
    println(pkg.Name)
}
```

不幸的是这次运行产生了以下错误：

```
pkgpath.NameData: missing Go type information for global symbol: size 8
```

错误提示汇编中定义的NameData符号没有类型信息。**其实Go汇编语言中定义的数据并没有所谓的类型，每个符号只不过是对应一块内存而已**，因此NameData符号也是没有类型的。但是Go语言是再带垃圾回收器的语言，而Go汇编语言是工作在自动垃圾回收体系框架内的。当Go语言的垃圾回收器在扫描到NameData变量的时候，无法知晓该变量内部是否包含指针，因此就出现了这种错误。错误的根本原因并不是NameData没有类型，而是NameData变量没有标注是否会含有指针信息。

通过给NameData变量增加一个NOPTR标志，表示其中不会包含指针数据可以修复该错误：

```
#include "textflag.h"

GLOBL ·NameData(SB),NOPTR,$8
```

通过给·NameData增加NOPTR标志的方式表示其中不含指针数据。我们也可以通过给·NameData变量在Go语言中增加一个不含指针并且大小为8个字节的类型来修改该错误：

```go
package pkg

var NameData [8]byte
var Name string
```

我们将NameData声明为长度为8的字节数组。编译器可以通过类型分析出该变量不会包含指针，因此汇编代码中可以省略NOPTR标志。现在垃圾回收器在遇到该变量的时候就会停止内部数据的扫描。

在这个实现中，Name字符串底层其实引用的是NameData内存对应的“gopher”字符串数据。因此，如果NameData发生变化，Name字符串的数据也会跟着变化。

```go
func main() {
    println(pkg.Name)

    pkg.NameData[0] = '?'
    println(pkg.Name)
}
```

当然这和字符串的只读定义是冲突的，正常的代码需要避免出现这种情况。最好的方法是不要导出内部的NameData变量，这样可以避免内部数据被无意破坏。

#### 1.2.3、汇编尝试2

在用汇编定义字符串时我们可以换一种思维：将底层的字符串数据和字符串头结构体定义在一起，这样可以避免引入NameData符号：

```asm
GLOBL ·Name(SB),$24

DATA ·Name+0(SB)/8,$·Name+16(SB)
DATA ·Name+8(SB)/8,$6
DATA ·Name+16(SB)/8,$"gopher"
```

在新的结构中，Name符号对应的内存从16字节变为24字节，多出的8个字节存放底层的“gopher”字符串。·Name符号前16个字节依然对应reflect.StringHeader结构体：Data部分对应`$·Name+16(SB)`，表示数据的地址为Name符号往后偏移16个字节的位置；Len部分依然对应6个字节的长度。这是C语言程序员经常使用的技巧。

## 2、伪寄存器：

Go汇编为了简化汇编代码的编写，引入了PC、FP、SP、SB四个伪寄存器。四个伪寄存器加其它的通用寄存器就是Go汇编语言对CPU的重新抽象，该抽象的结构也适用于其它非X86类型的体系结构。

四个伪寄存器和X86/AMD64的内存和寄存器的相互关系如下图：

![Go伪寄存器](./image/go/汇编相关/Go伪寄存器.png)

*图 3-3 Go汇编的伪寄存器*

在AMD64环境：

- 伪PC寄存器：其实是IP指令计数器寄存器的别名。
- 伪FP寄存器：对应的是函数的帧指针，一般用来访问函数的参数和返回值。（表示函数当前帧的地址，也就是第一个参数的地址，sk：指向参数和返回值栈的栈顶）。
- 伪SP寄存器：栈指针对应的是当前函数栈帧的**底部**（不包括参数和返回值部分，真SP表示函数栈帧顶部），一般用于定位局部变量。伪SP是一个比较特殊的寄存器，因为还存在一个同名的SP真寄存器。真SP寄存器对应的是栈的顶部，一般用于定位调用其它函数的参数和返回值。
- 伪SB寄存器：把SB想象为一个和内容容量有相同大小的字节数组，所有的静态全局符号通常可以通过SB加一个偏移量定位，而我们定义的符号其实就是相对于SB内存开始地址偏移量。对于SB伪寄存器，全局变量和全局函数的符号并没有任何区别。

**当需要区分伪寄存器和真寄存器的时候只需要记住一点**：伪寄存器一般需要一个标识符和偏移量为前缀，如果没有标识符前缀则是真寄存器。比如`(SP)`、`+8(SP)`没有标识符前缀为真SP寄存器，而`a(SP)`、`b+8(SP)`有标识符为前缀表示伪寄存器。

## 3、函数调用：

### 3.1、函数的定义

函数的定义的语法如下：

```asm
TEXT symbol(SB), [flags,] $framesize[-argsize]
```

函数的定义部分由5个部分组成：TEXT指令、函数名、可选的flags标志、函数帧大小和可选的函数参数大小。

- TEXT：用于定义函数符号，函数名中当前包的路径可以省略。
- symbol：函数的名字后面是`(SB)`，表示是函数名符号相对于SB伪寄存器的偏移量，二者组合在一起最终是绝对地址。作为全局的标识符的全局变量和全局函数的名字一般都是基于SB伪寄存器的相对地址。
- flags：标志部分用于指示函数的一些特殊行为，标志在`textlags.h`文件中定义，常见的`NOSPLIT`主要用于指示叶子函数不进行栈分裂。
- framesize：表示函数的局部变量需要多少栈空间，其中包含调用其它函数时准备调用参数的隐式栈空间。
- argsize：参数大小，之所以可以省略是因为编译器可以从Go语言的函数声明中推导出函数参数的大小。

如果用Go语言中声明Swap函数，大概这样的：

```go
package main

//go:nosplit
func Swap(a, b int) (int, int)
```

下面是main包中Swap函数在汇编中两种定义方式：

```asm
// func Swap(a, b int) (int, int)
TEXT ·Swap(SB), NOSPLIT, $0-32

// func Swap(a, b int) (int, int)
TEXT ·Swap(SB), NOSPLIT, $0
```

下图是Swap函数几种不同写法的对比关系图：

![函数定义](./image/go/汇编相关/函数定义.png)

*图 3-8 函数定义*

第一种是最完整的写法：函数名部分包含了当前包的路径，同时指明了函数的参数大小为32个字节（对应参数和返回值的4个int类型）。第二种写法则比较简洁，省略了当前包的路径和参数的大小。如果有NOSPLIT标注，会禁止汇编器为汇编函数插入栈分裂的代码。NOSPLIT对应Go语言中的`//go:nosplit`注释。

目前可能遇到的函数标志有NOSPLIT、WRAPPER和NEEDCTXT几个。其中NOSPLIT不会生成或包含栈分裂代码，这一般用于没有任何其它函数调用的叶子函数，这样可以适当提高性能。WRAPPER标志则表示这个是一个包装函数，在panic或runtime.caller等某些处理函数帧的地方不会增加函数帧计数。最后的NEEDCTXT表示需要一个上下文参数，一般用于闭包函数。

需要注意的是函数也没有类型，上面定义的Swap函数签名可以下面任意一种格式：

```asm
func Swap(a, b, c int) int
func Swap(a, b, c, d int)
func Swap() (a, b, c, d int)
func Swap() (a []int, d int)
// ...
```

对于汇编函数来说，只要是函数的名字和参数大小一致就可以是相同的函数了。而且在Go汇编语言中，输入参数和返回值参数是没有任何的区别的。

### 3.2、函数参数&返回值

对于函数来说，最重要的是函数对外提供的API约定，包含函数的名称、参数和返回值。当这些都确定之后，如何精确计算参数和返回值的大小是第一个需要解决的问题。

比如有一个Swap函数的签名如下：

```go
func Swap(a, b int) (ret0, ret1 int)
```

对于这个函数，我们可以轻易看出它需要4个int类型的空间，参数和返回值的大小也就是32个字节：

```asm
TEXT ·Swap(SB), $0-32
```

那么如何在汇编中引用这4个参数呢？为此Go汇编中引入了一个FP伪寄存器，表示函数当前帧的地址，也就是第一个参数的地址。因此我们以通过`+0(FP)`、`+8(FP)`、`+16(FP)`和`+24(FP)`来分别引用a、b、ret0和ret1四个参数。

但是在汇编代码中，我们并不能直接以`+0(FP)`的方式来使用参数。为了编写易于维护的汇编代码，Go汇编语言要求，任何通过FP伪寄存器访问的变量必和一个临时标识符前缀组合后才能有效，一般使用参数对应的变量名作为前缀。

下图是Swap函数中参数和返回值在内存中的布局图：

![函数参数返回值](./image/go/汇编相关/函数参数返回值.png)

*图 3-9 函数定义*

下面的代码演示了如何在汇编函数中使用参数和返回值：

```asm
TEXT ·Swap(SB), $0
    MOVQ a+0(FP), AX     // AX = a
    MOVQ b+8(FP), BX     // BX = b
    MOVQ BX, ret0+16(FP) // ret0 = BX
    MOVQ AX, ret1+24(FP) // ret1 = AX
    RET
```

从代码可以看出a、b、ret0和ret1的内存地址是依次递增的，FP伪寄存器是第一个变量的开始地址。

### 3.3、内存布局：参数&返回值

如果是参数和返回值类型比较复杂的情况该如何处理呢？下面我们再尝试一个更复杂的函数参数和返回值的计算。比如有以下一个函数：

```go
func Foo(a bool, b int16) (c []byte)
```

函数的参数有不同的类型，而且返回值中含有更复杂的切片类型。我们该如何计算每个参数的位置和总的大小呢？

其实函数参数和返回值的大小以及对齐问题和结构体的大小和成员对齐问题是一致的，函数的第一个参数和第一个返回值会分别进行一次地址对齐。我们可以用诡代思路将全部的参数和返回值以同样的顺序分别放到两个结构体中，将FP伪寄存器作为唯一的一个指针参数，而每个成员的地址也就是对应原来参数的地址。

Foo函数的参数和返回值的大小和内存布局：

![函数参数返回值内存布局](./image/go/汇编相关/函数参数返回值内存布局.png)

*图 3-10 函数的参数*

下面的代码演示了Foo汇编函数参数和返回值的定位：

```asm
TEXT ·Foo(SB), $0
    MOVEQ a+0(FP),       AX // a
    MOVEQ b+2(FP),       BX // b
    MOVEQ c_dat+8*1(FP), CX // c.Data
    MOVEQ c_len+8*2(FP), DX // c.Len
    MOVEQ c_cap+8*3(FP), DI // c.Cap
    RET
```

其中a和b参数之间出现了一个字节的空洞，b和c之间出现了4个字节的空洞。出现空洞的原因是要保证每个参数变量地址都要对齐到相应的倍数。

### 3.4、函数中的局部变量

从Go语言函数角度讲，局部变量是函数内明确定义的变量，同时也包含函数的参数和返回值变量。但是**从Go汇编角度看，局部变量是指函数运行时，在当前函数栈帧所对应的内存内的变量，不包含函数的参数和返回值（因为访问方式有差异）**。**函数栈帧的空间主要由函数参数和返回值、局部变量和被调用其它函数的参数和返回值空间组成**。为了便于理解，我们可以将汇编函数的局部变量类比为Go语言函数中显式定义的变量，不包含参数和返回值部分。

为了便于访问局部变量，Go汇编语言引入了伪SP寄存器，对应当前栈帧的底部。因为在当前栈帧时栈的底部是固定不变的，因此局部变量的相对于伪SP的偏移量也就是固定的，这可以简化局部变量的维护工作。SP真伪寄存器的区分只有一个原则：如果使用SP时有一个临时标识符前缀就是伪SP，否则就是真SP寄存器。比如`a(SP)`和`b+8(SP)`有a和b临时前缀，这里都是伪SP，而前缀部分一般用于表示局部变量的名字。而`(SP)`和`+8(SP)`没有临时标识符作为前缀，它们都是真SP寄存器。

在X86平台，函数的调用栈是从高地址向低地址增长的，因此伪SP寄存器对应栈帧的底部其实是对应更大的地址。当前栈的顶部对应真实存在的SP寄存器，对应当前函数栈帧的栈顶，对应更小的地址。如果整个内存用Memory数组表示，那么`Memory[0(SP):end-0(SP)]`就是对应当前栈帧的切片，其中开始位置是真SP寄存器，结尾部分是伪SP寄存器。真SP寄存器一般用于表示调用其它函数时的参数和返回值，真SP寄存器对应内存较低的地址，所以被访问变量的偏移量是正数；而伪SP寄存器对应高地址，对应的局部变量的偏移量都是负数。

为了便于对比，我们将前面Foo函数的参数和返回值变量改成局部变量：

```go
func Foo() {
    var c []byte
    var b int16
    var a bool
}
```

然后通过汇编语言重新实现Foo函数，并通过伪SP来定位局部变量：

```asm
TEXT ·Foo(SB), $32-0
    MOVQ a-32(SP),      AX // a
    MOVQ b-30(SP),      BX // b
    MOVQ c_data-24(SP), CX // c.Data
    MOVQ c_len-16(SP),  DX // c.Len
    MOVQ c_cap-8(SP),   DI // c.Cap
    RET
```

Foo函数有3个局部变量，但是没有调用其它的函数，因为对齐和填充的问题导致函数的栈帧大小为32个字节。因为Foo函数没有参数和返回值，因此参数和返回值大小为0个字节，当然这个部分可以省略不写。而局部变量中先定义的变量c离伪SP寄存器对应的地址最近，最后定义的变量a离伪SP寄存器最远。有两个因素导致出现这种逆序的结果：

- 一个从Go语言函数角度理解，先定义的c变量地址要比后定义的变量的地址更大；
- 另一个是伪SP寄存器对应栈帧的底部，而X86中栈是从高向低生长的，所以最先定义有着更大地址的c变量离栈的底部伪SP更近。

我们同样可以通过结构体来模拟局部变量的布局：

```go
func Foo() {
    var local [1]struct{
        a bool
        b int16
        c []byte
    }
    var SP = &local[1];

    _ = -(unsafe.Sizeof(local)-unsafe.Offsetof(local.a)) + uintptr(&SP) // a
    _ = -(unsafe.Sizeof(local)-unsafe.Offsetof(local.b)) + uintptr(&SP) // b
    _ = -(unsafe.Sizeof(local)-unsafe.Offsetof(local.c)) + uintptr(&SP) // c
}
```

我们将之前的三个局部变量挪到一个结构体中。然后构造一个SP变量对应伪SP寄存器，对应局部变量结构体的顶部。然后根据局部变量总大小和每个变量对应成员的偏移量计算相对于伪SP的距离，最终偏移量是一个负数。

通过这种方式可以处理复杂的局部变量的偏移，同时也能保证每个变量地址的对齐要求。当然，除了地址对齐外，局部变量的布局并没有顺序要求。对于汇编比较熟悉同学可以根据自己的习惯组织变量的布局。

下面是Foo函数的局部变量的大小和内存布局：

![函数中的局部变量](./image/go/汇编相关/函数中的局部变量.png)

*图 3-11 函数的局部变量*

从图中可以看出Foo函数局部变量和前一个例子中参数和返回值的内存布局是完全一样的，这也是我们故意设计的结果。

- 但参数和返回值是通过伪FP寄存器定位的：FP寄存器对应**第一个参数**的**开始地址**（第一个参数地址较低），因此每个变量的偏移量是正数。
- 局部变量是通过伪SP寄存器定位的：伪SP寄存器对应的是**第一个局部变量**的**结束地址**（第一个局部变量地址较大），因此每个局部变量的偏移量都是负数。

### 3.5、调用其它函数

**常见的用Go汇编实现的函数都是叶子函数，也就是被其它函数调用的函数，但是很少调用其它函数**。这主要是因为叶子函数比较简单，可以简化汇编函数的编写；同时一般性能或特性的瓶颈也处于叶子函数。但是能够调用其它函数和能够被其它函数调用同样重要，否则Go汇编就不是一个完整的汇编语言。

在前文中我们已经学习了一些汇编实现的函数参数和返回值处理的规则。那么一个显然的问题是，汇编函数的参数是从哪里来的？答案同样明显，被调用函数的参数是由调用方准备的：

- 调用方在栈上设置好空间和数据后调用函数
- 被调用方在返回前将返回值放在对应的位置，函数通过RET指令返回调用方函数之后，
- 调用方再从返回值对应的栈内存位置取出结果。
- Go语言函数的调用参数和返回值均是通过栈传输的，这样做的优点是函数调用栈比较清晰，缺点是函数调用有一定的性能损耗（Go编译器是通过函数内联来缓解这个问题的影响）。

为了便于展示，我们先使用Go语言来构造三个逐级调用的函数：

```go
func main() {
    printsum(1, 2)
}

func printsum(a, b int) {
    var ret = sum(a, b)
    println(ret)
}

func sum(a, b int) int {
    return a+b
}
```

其中main函数通过字面值常量直接调用printsum函数，printsum函数输出两个整数的和。而printsum函数内部又通过调用sum函数计算两个数的和，并最终调用打印函数进行输出。因为printsum既是被调用函数又是调用函数，所以它是我们要重点分析的函数。

下图展示了三个函数逐级调用时内存中函数参数和返回值的布局：

![函数调用](./image/go/汇编相关/函数调用.png)

*图 3-12 函数帧*

为了便于理解，我们对真实的内存布局进行了简化。要记住：

- 调用函数时，被调用函数的参数和返回值内存空间都必须由调用者提供。
- 因此函数的局部变量和为调用其它函数准备的栈空间总和就确定了**函数帧的大小**。
- 调用其它函数前调用方要选择保存相关寄存器到栈中，并在调用函数返回后选择要恢复的寄存器进行保存。
- 最终通过CALL指令调用函数的过程和调用我们熟悉的调用println函数输出的过程类似。

Go语言中函数调用是一个复杂的问题，因为Go函数不仅仅要了解函数调用参数的布局，还会涉及到栈的跳转，栈上局部变量的生命周期管理。本节只是简单了解函数调用参数的布局规则，在后续的章节中会更详细的讨论函数的细节。

和C语言函数不同，Go语言函数的参数和返回值完全通过栈传递。回顾以下Go函数调用时栈的布局图：

![函数调用参数布局](./image/go/汇编相关/函数调用参数布局.png)

## 4、再论函数

在前面的章节中我们已经简单讨论过Go的汇编函数，但是那些主要是叶子函数。叶子函数的最大特点是不会调用其他函数，也就是栈的大小是可以预期的，叶子函数也就是可以基本忽略爆栈的问题（如果已经爆了，那也是上级函数的问题）。如果没有爆栈问题，那么也就是不会有栈的分裂问题；如果没有栈的分裂也就不需要移动栈上的指针，也就不会有栈上指针管理的问题。但是是现实中Go语言的函数是可以任意深度调用的，永远不用担心爆栈的风险。那么这些近似黑科技的特性是如何通过低级的汇编语言实现的呢？这些都是本节尝试讨论的问题。

### 4.1、函数调用规范

在Go汇编语言中CALL指令用于调用函数，RET指令用于从调用函数返回。但是CALL和RET指令并没有处理函数调用时输入参数和返回值的问题。CALL指令类似`PUSH IP`和`JMP somefunc`两个指令的组合，首先将当前的IP指令寄存器的值压入栈中，然后通过JMP指令将要调用函数的地址写入到IP寄存器实现跳转。而RET指令则是和CALL相反的操作，基本和`POP IP`指令等价，也就是将执行CALL指令时保存在SP中的返回地址重新载入到IP寄存器，实现函数的返回。

和C语言函数不同，Go语言函数的参数和返回值完全通过栈传递。下面是Go函数调用时栈的布局图：

![函数调用参数布局](./image/go/汇编相关/函数调用参数布局.png)

*图 3-13 函数调用参数布局*

首先是调用函数前准备的输入参数和返回值空间。然后CALL指令将首先触发返回地址入栈操作。在进入到被调用函数内之后，汇编器自动插入了BP寄存器相关的指令，因此BP寄存器和返回地址是紧挨着的。再下面就是当前函数的局部变量的空间，包含再次调用其它函数需要准备的调用参数空间。被调用的函数执行RET返回指令时，先从栈恢复BP和SP寄存器，接着取出的返回地址跳转到对应的指令执行。

### 4.2、高级汇编语言

Go汇编语言其实是一种高级的汇编语言。在这里高级一词并没有任何褒义或贬义的色彩，而是要强调Go汇编代码和最终真实执行的代码并不完全等价。Go汇编语言中一个指令在最终的目标代码中可能会被编译为其它等价的机器指令。Go汇编实现的函数或调用函数的指令在最终代码中也会被插入额外的指令。要彻底理解Go汇编语言就需要彻底了解汇编器到底插入了哪些指令。

为了便于分析，我们先构造一个禁止栈分裂的printnl函数。printnl函数内部都通过调用runtime.printnl函数输出换行：

```
TEXT ·printnl_nosplit(SB), NOSPLIT, $8
    CALL runtime·printnl(SB)
    RET
```

然后通过`go tool asm -S main_amd64.s`指令查看编译后的目标代码：

```asm
"".printnl_nosplit STEXT nosplit size=29 args=0xffffffff80000000 locals=0x10
0x0000 00000 (main_amd64.s:5) TEXT "".printnl_nosplit(SB), NOSPLIT    $16
0x0000 00000 (main_amd64.s:5) SUBQ $16, SP

0x0004 00004 (main_amd64.s:5) MOVQ BP, 8(SP)
0x0009 00009 (main_amd64.s:5) LEAQ 8(SP), BP

0x000e 00014 (main_amd64.s:6) CALL runtime.printnl(SB)

0x0013 00019 (main_amd64.s:7) MOVQ 8(SP), BP
0x0018 00024 (main_amd64.s:7) ADDQ $16, SP
0x001c 00028 (main_amd64.s:7) RET
```

输出代码中我们删除了非指令的部分。为了便于讲述，我们将上述代码重新排版，并根据缩进表示相关的功能：

```asm
TEXT "".printnl(SB), NOSPLIT, $16
    SUBQ $16, SP
        MOVQ BP, 8(SP)
        LEAQ 8(SP), BP
            CALL runtime.printnl(SB)
        MOVQ 8(SP), BP
    ADDQ $16, SP
RET
```

- 第一层是TEXT指令表示函数开始，到RET指令表示函数返回。
- 第二层是`SUBQ $16, SP`指令为当前函数帧分配16字节的空间，在函数返回前通过`ADDQ $16, SP`指令回收16字节的栈空间。我们谨慎猜测在第二层是为函数多分配了8个字节的空间。那么为何要多分配8个字节的空间呢？
- 第三层的指令：开始部分有两个指令`MOVQ BP, 8(SP)`和`LEAQ 8(SP), BP`，首先是将BP寄存器保存到多分配的8字节栈空间，然后将`8(SP)`地址重新保存到了BP寄存器中；结束部分是`MOVQ 8(SP), BP`指令则是从栈中恢复之前备份的前BP寄存器的值。
- 第四次层才是我们写的代码，调用runtime.printnl函数输出换行。

如果去掉NOSPILT标志，再重新查看生成的目标代码，会发现在函数的开头和结尾的地方又增加了新的指令。下面是经过缩进格式化的结果：

```asm
TEXT "".printnl_nosplit(SB), $16
L_BEGIN:
    MOVQ (TLS), CX
    CMPQ SP, 16(CX)
    JLS  L_MORE_STK
        SUBQ $16, SP
            MOVQ BP, 8(SP)
            LEAQ 8(SP), BP
                CALL runtime.printnl(SB)
            MOVQ 8(SP), BP
        ADDQ $16, SP

L_MORE_STK:
    CALL runtime.morestack_noctxt(SB)
    JMP  L_BEGIN
RET
```

其中开头有三个新指令：

- `MOVQ (TLS), CX`用于加载g结构体指针
- 第二个指令`CMPQ SP, 16(CX)`SP栈指针和g结构体中stackguard0成员比较，如果比较的结果小于0则跳转到结尾的L_MORE_STK部分。当获取到更多栈空间之后，通过`JMP L_BEGIN`指令跳转到函数的开始位置重新进行栈空间的检测。

g结构体在`$GOROOT/src/runtime/runtime2.go`文件定义，开头的结构成员如下：

```go
type g struct {
    // Stack parameters.
    stack       stack   // offset known to runtime/cgo
    stackguard0 uintptr // offset known to liblink
    stackguard1 uintptr // offset known to liblink

    ...
}
```

第一个成员是stack类型，表示当前栈的开始和结束地址。stack的定义如下：

```go
// Stack describes a Go execution stack.
// The bounds of the stack are exactly [lo, hi),
// with no implicit data structures on either side.
type stack struct {
    lo uintptr
    hi uintptr
}
```

在g结构体中的stackguard0成员是出现爆栈前的警戒线。stackguard0的偏移量是16个字节，因此上述代码中的`CMPQ SP, 16(AX)`表示将当前的真实SP和爆栈警戒线比较，如果超出警戒线则表示需要进行栈扩容，也就是跳转到L_MORE_STK。在L_MORE_STK标号处，先调用runtime·morestack_noctxt进行栈扩容，然后又跳回到函数的开始位置，此时此刻函数的栈已经调整了。然后再进行一次栈大小的检测，如果依然不足则继续扩容，直到栈足够大为止。

以上是栈的扩容，但是栈的收缩是在何时处理的呢？我们知道Go运行时会定期进行垃圾回收操作，这其中包含栈的回收工作。如果栈使用到比例小于一定到阈值，则分配一个较小到栈空间，然后将栈上面到数据移动到新的栈中，栈移动的过程和栈扩容的过程类似。

### 4.3、PCDATA和FUNCDATA

Go语言中有个runtime.Caller函数可以获取当前函数的调用者列表。我们可以非常容易在运行时定位每个函数的调用位置，以及函数的调用链。因此在panic异常或用log输出信息时，可以精确定位代码的位置。

比如以下代码可以打印程序的启动流程：

```go
func main() {
    for skip := 0; ; skip++ {
        pc, file, line, ok := runtime.Caller(skip)
        if !ok {
            break
        }

        p := runtime.FuncForPC(pc)
        fnfile, fnline := p.FileLine(0)

        fmt.Printf("skip = %d, pc = 0x%08X\n", skip, pc)
        fmt.Printf("  func: file = %s, line = L%03d, name = %s, entry = 0x%08X\n", fnfile, fnline, p.Name(), p.Entry())
        fmt.Printf("  call: file = %s, line = L%03d\n", file, line)
    }
}
```

其中runtime.Caller先获取当时的PC寄存器值，以及文件和行号。然后根据PC寄存器表示的指令位置，通过runtime.FuncForPC函数获取函数的基本信息。Go语言是如何实现这种特性的呢？

Go语言作为一门静态编译型语言，在执行时每个函数的地址都是固定的，函数的每条指令也是固定的。如果针对每个函数和函数的每个指令生成一个地址表格（也叫PC表格），那么在运行时我们就可以根据PC寄存器的值轻松查询到指令当时对应的函数和位置信息。而Go语言也是采用类似的策略，只不过地址表格经过裁剪，舍弃了不必要的信息。因为要在运行时获取任意一个地址的位置，必然是要有一个函数调用，因此我们只需要为函数的开始和结束位置，以及每个函数调用位置生成地址表格就可以了。同时地址是有大小顺序的，在排序后可以通过只记录增量来减少数据的大小；在查询时可以通过二分法加快查找的速度。

在汇编中有个PCDATA用于生成PC表格，PCDATA的指令用法为：**`PCDATA tableid, tableoffset`**。PCDATA有个两个参数，第一个参数为表格的类型，第二个是表格的地址。在目前的实现中，有PCDATA_StackMapIndex和PCDATA_InlTreeIndex两种表格类型。两种表格的数据是类似的，应该包含了代码所在的文件路径、行号和函数的信息，只不过PCDATA_InlTreeIndex用于内联函数的表格。

此外对于汇编函数中返回值包含指针的类型，在返回值指针被初始化之后需要执行一个GO_RESULTS_INITIALIZED指令：

```asm
#define GO_RESULTS_INITIALIZED    PCDATA $PCDATA_StackMapIndex, $1
```

GO_RESULTS_INITIALIZED记录的也是PC表格的信息，表示PC指针越过某个地址之后返回值才完成被初始化的状态。

Go语言二进制文件中除了有PC表格，还有FUNC表格用于记录函数的参数、局部变量的指针信息。FUNCDATA指令和PCDATA的格式类似：**`FUNCDATA tableid, tableoffset`**，第一个参数为表格的类型，第二个是表格的地址。目前的实现中定义了三种FUNC表格类型：

- FUNCDATA_ArgsPointerMaps表示函数参数的指针信息表
- FUNCDATA_LocalsPointerMaps表示局部指针信息表
- FUNCDATA_InlTree表示被内联展开的指针信息表。

通过FUNC表格，Go语言的垃圾回收器可以跟踪全部指针的生命周期，同时根据指针指向的地址是否在被移动的栈范围来确定是否要进行指针移动。

在前面递归函数的例子中，我们遇到一个NO_LOCAL_POINTERS宏。它的定义如下：

```asm
#define FUNCDATA_ArgsPointerMaps 0 /* garbage collector blocks */
#define FUNCDATA_LocalsPointerMaps 1
#define FUNCDATA_InlTree 2

#define NO_LOCAL_POINTERS FUNCDATA $FUNCDATA_LocalsPointerMaps, runtime·no_pointers_stackmap(SB)
```

因此NO_LOCAL_POINTERS宏表示的是FUNCDATA_LocalsPointerMaps对应的局部指针表格，而runtime·no_pointers_stackmap是一个空的指针表格，也就是表示函数没有指针类型的局部变量。

PCDATA和FUNCDATA的数据一般是由编译器自动生成的，手工编写并不现实。如果函数已经有Go语言声明，那么编译器可以自动输出参数和返回值的指针表格。同时所有的函数调用一般是对应CALL指令，编译器也是可以辅助生成PCDATA表格的。编译器唯一无法自动生成是函数局部变量的表格，因此我们一般要在汇编函数的局部变量中谨慎使用指针类型。

对于PCDATA和FUNCDATA细节感兴趣的同学可以尝试从debug/gosym包入手，参考包的实现和测试代码。

### 4.4、方法函数

Go语言中方法函数和全局函数非常相似，比如有以下的方法：

```go
package main

type MyInt int

func (v MyInt) Twice() int {
    return int(v)*2
}

func MyInt_Twice(v MyInt) int {
    return int(v)*2
}
```

其中MyInt类型的Twice方法和MyInt_Twice函数的类型是完全一样的，只不过Twice在目标文件中被修饰为`main.MyInt.Twice`名称。我们可以用汇编实现该方法函数：

```asm
// func (v MyInt) Twice() int
TEXT ·MyInt·Twice(SB), NOSPLIT, $0-16
    MOVQ a+0(FP), AX   // v
    ADDQ AX, AX        // AX *= 2
    MOVQ AX, ret+8(FP) // return v
    RET
```

不过这只是接收非指针类型的方法函数。现在增加一个接收参数是指针类型的Ptr方法，函数返回传入的指针：

```go
func (p *MyInt) Ptr() *MyInt {
    return p
}
```

在目标文件中，Ptr方法名被修饰为`main.(*MyInt).Ptr`，也就是对应汇编中的`·(*MyInt)·Ptr`。不过在Go汇编语言中，星号和小括弧都无法用作函数名字，也就是无法用汇编直接实现接收参数是指针类型的方法。

在最终的目标文件中的标识符名字中还有很多Go汇编语言不支持的特殊符号（比如`type.string."hello"`中的双引号），这导致了无法通过手写的汇编代码实现全部的特性。或许是Go语言官方故意限制了汇编语言的特性。

### 4.5、递归函数: 1到n求和

递归函数是比较特殊的函数，递归函数通过调用自身并且在栈上保存状态，这可以简化很多问题的处理。Go语言中递归函数的强大之处是不用担心爆栈问题，因为栈可以根据需要进行扩容和收缩。

首先通过Go递归函数实现一个1到n的求和函数：

```go
// sum = 1+2+...+n
// sum(100) = 5050
func sum(n int) int {
    if n > 0 { return n+sum(n-1) } else { return 0 }
}
```

然后通过if/goto重构上面的递归函数，以便于转义为汇编版本：

```go
func sum(n int) (result int) {
    var AX = n
    var BX int

    if n > 0 { goto L_STEP_TO_END }
    goto L_END

L_STEP_TO_END:
    AX -= 1
    BX = sum(AX)

    AX = n // 调用函数后, AX重新恢复为n
    BX += AX

    return BX

L_END:
    return 0
}
```

在改写之后，递归调用的参数需要引入局部变量，保存中间结果也需要引入局部变量。而通过栈来保存中间的调用状态正是递归函数的核心。因为输入参数也在栈上，所以我们可以通过输入参数来保存少量的状态。同时我们模拟定义了AX和BX寄存器，寄存器在使用前需要初始化，并且在函数调用后也需要重新初始化。

下面继续改造为汇编语言版本：

```asm
// func sum(n int) (result int)
TEXT ·sum(SB), NOSPLIT, $16-16
    MOVQ n+0(FP), AX       // n
    MOVQ result+8(FP), BX  // result

    CMPQ AX, $0            // test n - 0
    JG   L_STEP_TO_END     // if > 0: goto L_STEP_TO_END
    JMP  L_END             // goto L_STEP_TO_END

L_STEP_TO_END:
    SUBQ $1, AX            // AX -= 1
    MOVQ AX, 0(SP)         // arg: n-1
    CALL ·sum(SB)          // call sum(n-1)
    MOVQ 8(SP), BX         // BX = sum(n-1)

    MOVQ n+0(FP), AX       // AX = n
    ADDQ AX, BX            // BX += AX
    MOVQ BX, result+8(FP)  // return BX
    RET

L_END:
    MOVQ $0, result+8(FP) // return 0
    RET
```

在汇编版本函数中并没有定义局部变量，只有用于调用自身的临时栈空间。因为函数本身的参数和返回值有16个字节，因此栈帧的大小也为16字节。L_STEP_TO_END标号部分用于处理递归调用，是函数比较复杂的部分。L_END用于处理递归终结的部分。

调用sum函数的参数在`0(SP)`位置，调用结束后的返回值在`8(SP)`位置。在函数调用之后要需要重新为需要的寄存器注入值，因为被调用的函数内部很可能会破坏了寄存器的状态。同时调用函数的参数值也是不可信任的，输入参数值也可能在被调用函数内部被修改了。

总得来说用汇编实现递归函数和普通函数并没有什么区别，当然是在没有考虑爆栈的前提下。我们的函数应该可以对较小的n进行求和，但是当n大到一定程度，也就是栈达到一定的深度，必然会出现爆栈的问题。爆栈是C语言的特性，不应该在哪怕是Go汇编语言中出现。

Go语言的编译器在生成函数的机器代码时，会在开头插入一小段代码。因为sum函数也需要深度递归调用，因此我们删除了NOSPLIT标志，让汇编器为我们自动生成一个栈扩容的代码：

```asm
// func sum(n int) int
TEXT ·sum(SB), $16-16
    NO_LOCAL_POINTERS

    // 原来的代码
```

除了去掉了NOSPLIT标志，我们还在函数开头增加了一个NO_LOCAL_POINTERS语句，该语句表示函数没有局部指针变量。栈的扩容必然要涉及函数参数和局部编指针的调整，如果缺少局部指针信息将导致扩容工作无法进行。不仅仅是栈的扩容需要函数的参数和局部指针标记表格，在GC进行垃圾回收时也将需要。函数的参数和返回值的指针状态可以通过在Go语言中的函数声明中获取，函数的局部变量则需要手工指定。因为手工指定指针表格是一个非常繁琐的工作，因此一般要避免在手写汇编中出现局部指针。

喜欢深究的读者可能会有一个问题：如果进行垃圾回收或栈调整时，寄存器中的指针是如何维护的？前文说过，Go语言的函数调用是通过栈进行传递参数的，并没有使用寄存器传递参数。同时函数调用之后所有的寄存器视为失效。因此在调整和维护指针时，只需要扫描内存中的指针数据，寄存器中的数据在垃圾回收器函数返回后都需要重新加载，因此寄存器是不需要扫描的。

### 4.6、闭包函数

闭包函数是最强大的函数，因为闭包函数可以捕获外层局部作用域的局部变量，因此闭包函数本身就具有了状态。从理论上来说，全局的函数也是闭包函数的子集，只不过全局函数并没有捕获外层变量而已。

为了理解闭包函数如何工作，我们先构造如下的例子：

```go
package main

func NewTwiceFunClosure(x int) func() int {
    return func() int {
        x *= 2
        return x
    }
}

func main() {
    fnTwice := NewTwiceFunClosure(1)

    println(fnTwice()) // 1*2 => 2
    println(fnTwice()) // 2*2 => 4
    println(fnTwice()) // 4*2 => 8
}
```

其中`NewTwiceFunClosure`函数返回一个闭包函数对象，返回的闭包函数对象捕获了外层的`x`参数。返回的闭包函数对象在执行时，每次将捕获的外层变量乘以2之后再返回。在`main`函数中，首先以1作为参数调用`NewTwiceFunClosure`函数构造一个闭包函数，返回的闭包函数保存在`fnTwice`闭包函数类型的变量中。然后每次调用`fnTwice`闭包函数将返回翻倍后的结果，也就是：2，4，8。

上述的代码，从Go语言层面是非常容易理解的。但是闭包函数在汇编语言层面是如何工作的呢？下面我们尝试手工构造闭包函数来展示闭包的工作原理。首先是构造`FunTwiceClosure`结构体类型，用来表示闭包对象：

```go
type FunTwiceClosure struct {
    F uintptr
    X int
}

func NewTwiceFunClosure(x int) func() int {
    var p = &FunTwiceClosure{
        F: asmFunTwiceClosureAddr(),
        X: x,
    }
    return ptrToFunc(unsafe.Pointer(p))
}
```

`FunTwiceClosure`结构体包含两个成员，第一个成员`F`表示闭包函数的函数指令的地址，第二个成员`X`表示闭包捕获的外部变量。如果闭包函数捕获了多个外部变量，那么`FunTwiceClosure`结构体也要做相应的调整。然后构造`FunTwiceClosure`结构体对象，其实也就是闭包函数对象。其中`asmFunTwiceClosureAddr`函数用于辅助获取闭包函数的函数指令的地址，采用汇编语言实现。最后通过`ptrToFunc`辅助函数将结构体指针转为闭包函数对象返回，该函数也是通过汇编语言实现。

汇编语言实现了以下三个辅助函数：

```go
func ptrToFunc(p unsafe.Pointer) func() int
func asmFunTwiceClosureAddr() uintptr
func asmFunTwiceClosureBody() int
```

- `ptrToFunc`：用于将指针转化为`func() int`类型的闭包函数
- `asmFunTwiceClosureAddr`：用于返回闭包函数机器指令的开始地址（类似全局函数的地址）
- `asmFunTwiceClosureBody`：是闭包函数对应的全局函数的实现。

然后用Go汇编语言实现以上三个辅助函数：

```asm
#include "textflag.h"

TEXT ·ptrToFunc(SB), NOSPLIT, $0-16
    MOVQ ptr+0(FP), AX // AX = ptr
    MOVQ AX, ret+8(FP) // return AX
    RET

TEXT ·asmFunTwiceClosureAddr(SB), NOSPLIT, $0-8
    LEAQ ·asmFunTwiceClosureBody(SB), AX // AX = ·asmFunTwiceClosureBody(SB)
    MOVQ AX, ret+0(FP)                   // return AX
    RET

TEXT ·asmFunTwiceClosureBody(SB), NOSPLIT|NEEDCTXT, $0-8
    MOVQ 8(DX), AX
    ADDQ AX   , AX        // AX *= 2
    MOVQ AX   , 8(DX)     // ctx.X = AX
    MOVQ AX   , ret+0(FP) // return AX
    RET
```

其中

- `·ptrToFunc`和`·asmFunTwiceClosureAddr`函数的实现比较简单，我们不再详细描述。
- 最重要的是`·asmFunTwiceClosureBody`函数的实现：它有一个`NEEDCTXT`标志。采用`NEEDCTXT`标志定义的汇编函数表示需要一个上下文环境，在AMD64环境下是通过`DX`寄存器来传递这个上下文环境指针，也就是对应`FunTwiceClosure`结构体的指针。函数首先从`FunTwiceClosure`结构体对象取出之前捕获的`X`，将`X`乘以2之后写回内存，最后返回修改之后的`X`的值。

如果是在汇编语言中调用闭包函数，也需要遵循同样的流程：首先为构造闭包对象，其中保存捕获的外层变量；在调用闭包函数时首先要拿到闭包对象，用闭包对象初始化`DX`，然后从闭包对象中取出函数地址并用通过`CALL`指令调用。

# 附录：

## 1、工具网站：

正则表达式生成： http://tool.rbtree.cn/

2、得到

