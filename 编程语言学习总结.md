# 一、语言基础
## 1、数据类型

### 1.1、类型概述

#### a、Java

在java语言中，变量分为两种：基本类型和引用类型。

基本数据类型是CPU可以直接进行运算的类型。Java定义了以下几种基本数据类型：

- 整数类型：byte、short、int、long
- 浮点数类型：float、double
- 字符类型：char
- 布尔类型：bool

#### b、Go

在Go语言中，数据类型用于声明函数和变量。

数据类型的出现是为了把数据分成所需内存大小不同的类型，编程的时候需要用大数据的时候才需要申请大内存，就可以充分利用内存。

所有类型都能赋值给interface{}空接口；GO语言中没有类的概念，只能通过struct和method来模拟；

Go语言按类别有以下几种数据类型：

1. 布尔型：bool
2. 数字类型：
   - 无符号整数：uint8、uint16、uint32、uint64
   - 有符号整数：int8、int16、int32、int64
   - 浮点数：float32、float64
   - 其它类型：
     - byte、uint8 ：两种类型可以互换，是一回事
     - rune、int32：两种类型可以互换，是一回事
     - int、uint：长度由CPU的位数决定(32或64位)、
     - uintptr：无符号整型，用于存放一个指针
   - 复数：complex64、conplex128
   - 字符：byte/uint8、rune 
     - uint8/byte代表ASCII的一个字符
     - rune代表一个UTF-8字符，代表中文、韩文等字符。
3. 字符串类型：string
4. 派生类型：
   - 指针类型（pointer）
   - 数组类型：
   - 结构体：struct
   - channel类型
   - 函数类型
   - 切片类型
   - 接口类型（interface）
   - Map类型

#### c、Python

变量就是变量，它没有类型；Python使用对象模型来存储数据，构造任何类型的值都是对象。对象都拥有三个特性：身份、类型、值。

身份：每个对象都有一个唯一的身份标识自己，任何对象的身份都可以通过内建函数id()来得到。

类型：对象的类型决定了对象可以保存什么类型的值，可以进行什么样的操作，以及遵循什么样的规则。可以通过type()查看对象类型。返回的是对象而不是简单的字符串。

值：对象表示的数据

Python3中有六个标准数据类型：

1. Number（数字）：int、float、bool、complex(复数)
2. String（字符串）
3. List（列表）
4. Tuple（元组）
5. Set（集合）
6. Dictionary（字典）

- 不可变数据类型：Number、String、Tuple
- 可变数据类型：List、Dictionary、Set

#### d、JavaScript

JavaScript变量均为对象。当声明一个变量时，就创建了一个新的对象。

JavaScript不区分整数和浮点数，统一使用Number表示。

值类型（基本类型）：String、Number、Boolean、Null、Undefined、Symbol

引用类型（对象类型）：Object、Array、Function、RegExp、Date

### 1.2、数据类型对比

| 类型       | Java                   | Go                                      | Python          | JavaScript      | 备注                                                         |
| ---------- | ---------------------- | --------------------------------------- | --------------- | --------------- | ------------------------------------------------------------ |
| byte       | byte                   | byte                                    |                 |                 |                                                              |
| bool       | bool                   | bool                                    | <class,bool>    |                 |                                                              |
| 有符号整数 | short/int/long         | int8/int16/int32/int64/int/rune         | <class,int>     |                 | Python bool继承int,可以当成int的0或1                         |
| 无符号整数 | --                     | uint8/uint16/uint32/uint64/uint/uintptr | --              |                 |                                                              |
| 浮点数     | float/double           | float32/float64                         | <class,float>   |                 |                                                              |
| 复数       | --                     | complex                                 | <class,complex> | --              |                                                              |
| 字符       | char                   | byte/uint8/rune                         | --              |                 | Go中字符有2种，uint8/byte代表ASCII的一个字符，rune代表一个UTF-8字符 |
| 指针       | --                     | pointer                                 | --              | --              |                                                              |
| 字符串     | String                 | string                                  | <class,str>     | String          |                                                              |
| 空         | null                   | nil                                     | None            | null、undefined |                                                              |
| 元组       | --                     | --                                      | <class,tuple>   | --              |                                                              |
| 数组       | Array                  | array                                   | --              | Array           |                                                              |
| List       | ArrayList/LinkedList等 | slice                                   | <class,list>    | List            |                                                              |
| Map        | HashMap/TreeMap等      | map                                     | <class,dict>    | Map             |                                                              |
| Set        | HashSet/TreeSet等      | --                                      | <class,set>     | Set             |                                                              |
| 结构体     | --                     | struct                                  | --              | --              |                                                              |
| 函数       | 成员函数               | func（函数和方法）                      | def             | Function        |                                                              |
| 接口       | Interface              | interface                               |                 | --              |                                                              |
| 类         | Class                  | --                                      | Class           | Class           |                                                              |
| Channel    | --                     | channel                                 | --              | --              |                                                              |

## 2、变量
### 2.1、变量声明(定义)

#### a、Java

```java
// 方式一： 数据类型 变量名 = 赋值;
// 方式二： var 变量名 = 赋值;  // JDK10 局部变量类型推断，可以使用var代替实际类型

String name = "skwqy";
int age = 100;
var name2 = "skwqy";
```

#### b、GO

```go
// 方式一： var 变量名 数据类型 = 赋值	  	// 完整形式
// 方式二： var 变量名 = 赋值           	// 类型推断，省略数据类型
// 方式三： 变量名 := 赋值			        	// 简短声明，省略var关键字

var name string = "skwqy"
var name = "skwqy"
name := "skwqy"
```

#### c、Python

```python
# Python中变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建
name = 'skwqy'
name2 = "sk"
x = 10
```

#### d、JavaScript

```javascript
// 方式一： var 变量名 = 赋值
// 方式二： let 变量名 = 赋值 （推荐）
// 方式三： const 变量名 = 赋值 （常量）
// let 声明的变量仅在块级作用域中有效。注意：let不允许在相同的作用域内，重复声明同一个变量。
// -------------------------------------------------
{
    let a = 10;
    var b = 1;
}
a // ReferenceError: a is not defined. 
b //1
// -------------------------------------------------
var a = [];
for (var i = 0; i < 10; i++) {
  var c = i;
  a[i] = function () {
    console.log(c);
  };
}
a[6](); // 9
// --------------------------------------------------
var a = [];
for (let i = 0; i < 10; i++) {
  let c = i;
  a[i] = function () {
    console.log(c);
  };
}
a[6](); // 6
```



### 2.2、常量

常量一旦声明，常量的值就不能改变。

#### a、Java

```java
// Java 常量使用final来修饰
public static final float PI = 3.14;
```

#### b、Go

```Go
// Go 常量使用const来修饰
const PI float32 = 3.14
const PI2 = 3.14
```

#### c、Python

```python
# Python 中没有定义常量的关键字，也不存在受编译器保护的常量
# 常量只是程序员之间的默契，不收解析器的保护：使用大写字母和下划线来表示常量
PI = 3.14
```

#### d、JavaScript

```javascript
const PI = 3.14
```

### 2.3、常用数据结构

#### 2.3.1、字符串



##### 1、字符串的声明和定义

###### a、Java

```java
// 方式一：字面量定义，常量池
String name = "字符串定义";
            
// 方式二：new 对象定义，堆中
String name2 = new String("字符串定义2");

// 方式三：局部变量推断,仅限于函数内部定义局部变量 JDK提供该功能
var name3 = "字符串定义3";

// 方式4：Text块 JDK14提供该功能
String names = """
        hello
        skwqy
        周峰
        """;
```

###### b、Go

```go
// 方式一：通过双引号创建字符串
var name string = "字符串"

// 方式二：通过反引号(``)来创建，也称为原始文本。不支持转义字符，可以跨越多行，可以包含除反引号之外的任何字符。
// 通常，它用于在正则表达式或HTML中编写多行消息。
var name2 string = `hello
skwqy`
```

###### c、Python

Python中没有字符类型，一个字符也是字符串。

```python
# 方式一： 单引号，单行,可以包含双引号
name = '我叫"老大哥"'
# 方式二： 双引号，单行，可以包含单引号
name2 = "请叫我'老大哥'"
# 方式三：三个单引号，多行，可以包含单、双引号
name3 = '''请叫我
"老大哥'你好'"'''
# 方式四： 三个双引号，多行，可以包含单、双引号
name4 = """请叫我
'老大哥'
"你好"
"""

# 原始字符串,字符串不会转义，原样输出
# 方式一：不能包含单引号(')
rname = r'test\t123'
# 方式一：不能包含双引号(")
rname2 = R"test\t123"
# 方式三：可以包含单、双引号
rname3 = r'''姓名'''
# 方式四：可以包含单、双引号
rname4 = R"""姓名"""
```

###### d、JavaScript

```javascript
// 方式一：单引号，字符串内容可以包含双引号
var name1 = '请叫我"老大哥"'

// 方式二：双引号，字符串内容可以包含单引号
let name2 = "请叫我'老大哥'"

// 方式三：反引号,多行字符串，可以包含单、双引号
const name3 = `请叫我
"老大哥"
'OK'`
```

##### 2、字符子串

###### a、Java

```java
String oriStr="012345678";
String sub1 = oriStr.substring(1);  // 12345678
String sub2=oriStr.substring(2,5);  // 234
```

###### b、Go

```go
var oriStr = "012345678"
println(oriStr[1:])  // 12345678
println(oriStr[2:5]) // 234
println(oriStr[:5])  // 01234
```

###### c、Python

```python
oriStr = "012345678"
print(oriStr[1:])   # 12345678
print(oriStr[2:5])  # 234
print(oriStr[:5])   # 01234
```

###### d、JavaScript

```javascript
let oriStr = "012345678"
console.log(oriStr.substring(1))        // 12345678
console.log(oriStr.substring(2,5))      // 234
```

##### 3、字符串分割

###### a、Java

```java
String oriStr="123:456:789";
String[] members = oriStr.split(":");
```

###### b、Go

```go
findStr := "123:456:789"
arr := strings.Split(findStr, ":")
fmt.Println(arr) // [123 456 789]
```

###### c、Python

```python
findStr = "123:456:789"
arr = findStr.split(":")
print(arr)  # ['123', '456', '789']
```

###### d、JavaScript

```javascript
findStr = "123:456:789"
arr = findStr.split(":")
console.log(arr)    // [ '123', '456', '789' ]
```

##### 4、字符串查找

###### a、Java

```java
String oriStr = "123:456:789:我爱中国";
int index = oriStr.indexOf(":");
System.out.println(oriStr.substring(index));        // :456:789:我爱中国
int lastIndex = oriStr.lastIndexOf(":");
System.out.println(oriStr.substring(lastIndex));    // :我爱中国
```

###### b、Go

```go
findSubStr := "123:456:789:我爱中国"
index := strings.IndexAny(findSubStr, ":")
fmt.Println(findSubStr[index:]) // :456:789:我爱中国
lastIndex := strings.LastIndexAny(findSubStr, ":")
fmt.Println(findSubStr[lastIndex:]) //:我爱中国
```

###### c、Python

```python
findSubStr = "123:456:789:我爱中国"
index = findSubStr.find(":")
print(findSubStr[index:])  # :456:789:我爱中国
lastIndex = findSubStr.rfind(":")
print(findSubStr[lastIndex:])  # :我爱中国
```

###### d、JavaScript

```javascript
findSubStr = "123:456:789:我爱中国"
index = findSubStr.indexOf(":")
console.log(findSubStr.substring(index)) // :456:789:我爱中国
lastIndex = findSubStr.lastIndexOf(":")
console.log(findSubStr.substring(lastIndex)) //:我爱中国
```



##### 5、字符替换

###### a、Java

```java

```

###### b、Go

```go

```

###### c、Python

```python

```

###### d、JavaScript

```javascript

```



#### 2.3.2、数组

Java和Go语言中的数组在创建时需要指定存放数据类型和数组大小，数组一旦创建，其大小是不能改变的。且数组中存放的数据类型也是确定的，虽然Go语言可以创建interface{}数组来存放任何数据类型（包含基本数据类型int8、uint8等）

Python和JavaScript这种动态语言中的数组在创建时，不需要指定大小和数据类型。无需指定大小这种特性更想Java中的List和Go中的切片Slice。

##### 1、数组创建

###### a、Java

```java
// 方式一：
String[] names = new String[3];
names[0] = "skwqy";
names[1] = "sk";
names[2] = "skwqy2";

String[] names1 = new String[]{"skwqy", "sk", "skwqy2"};
System.out.println(names1.length); // 3

// 方式二：
String[] names2 = {"skwqy", "sk", "skwqy2"};
System.out.println(names2.length);// 3
```

###### b、Go

```go
// 方式一：指定容量，创建
var names [3]string
names[0] = "小明"
names[1] = "王二狗"
fmt.Println(names)                  // [小明 王二狗 ]
fmt.Println(len(names), cap(names)) // 3 3

// 方式二：指定容量，创建并初始化
var name2 [3]string = [3]string{"王二狗", "李小花", "张三丰"}
fmt.Println(name2) // [王二狗 李小花 张三丰]

// 方式三：指定容量，按照索引进行初始化
name3 := [3]string{1: "郭靖", 2: "黄蓉"}
fmt.Println(name3) // [ 郭靖 黄蓉]

// 方式四：匹配容量，
name4 := [...]string{"0", "1", "2", "3"}
fmt.Println(name4)                  // [0 1 2 3]
fmt.Println(len(name4), cap(name4)) // 4 4

// 方式五：匹配容量，指定索引
name5 := [...]string{0: "姓名0", 6: "姓名6"}
fmt.Println(name5)                  // [姓名0      姓名6]
fmt.Println(len(name5), cap(name5)) // 7 7
```

###### c、Python

```python
# Python 中没有数组的概念
```

###### d、JavaScript

```javascript
// JavaScript中的数组更向Java中的List，Go中的Slcie，放到List结构中进行对比
```



##### 2、数组遍历

###### a、Java

```java
String[] names = {"欧阳修", "苏轼", "王安石"};
// 方式一：
for (int index = 0; index < names.length; index++) {
    var name = names[index];
    System.out.println(name);
}

// 方式二：
for(var name:names){
    System.out.println(name);
}

// 方式三：
Arrays.stream(names).forEach(name-> System.out.println(name));
```

###### b、Go

```go
namess := [...]string{"欧阳修", "苏轼", "王安石"}
// 方式一
for i := 0; i < len(namess); i++ {
	fmt.Println(namess[i])
}

// 方式二
for index, name := range namess {
	fmt.Println(index, name)
}
```

###### c、Python

```python
# Python 中没有数组的概念
```

###### d、JavaScript

```javascript
// JavaScript中的数组更向Java中的List，Go中的Slcie，放到List结构中进行对比
```

#### 2.3.3、List 切片

Java中的List是定义为接口，jdk包括用户都可以基于该接口实现自己的List实现类。当前Java中实现List接口的数据结构有：

- ArrayList：非线程安全，底层数组数组实现
- LinkedList：非线程安全，底层使用链表实现
- CopyOnWriteArrayList：线程安全
- ......

Go、Python、JavaScript的类List都是编程语言内置的，Go语言的Slice、Python的<class 'list'>、JavaScript的Array都是语言内置的，提供容量动态增长特性，并提供丰富的操作接口。

##### 1、创建

###### a、Java

```java
// 方式一：
var list1 = new ArrayList<>(20);

// 方式二：
var list2 = Arrays.asList("王安石", "苏轼");

// 方式三：
var list3 = List.of("王安石", "苏轼");

// 方式四：
var list4 = Stream.of("王安石", "苏轼").toList();
```

###### b、Go

```go
// 1. 数组
var arr [3]string

// 2.切片
// 方式一：
var s1 []string                                 // 注意没有长度，有长度的是数组，没有长度的是切片slice
fmt.Printf("容量:%d， 长度:%d \n", cap(s1), len(s1)) // 容量:0， 长度:0

// 方式二：和方式一没啥区别，就是创建并初始化
s2 := []string{"王安石", "苏轼"}
fmt.Printf("容量:%d， 长度:%d \n", cap(s2), len(s2)) // 容量:2， 长度:2
fmt.Printf("%T,%T\n", arr, s2)                  // [3]string,[]string

// 方式三：指定长度和容量
s3 := make([]string, 3, 8)
fmt.Printf("容量:%d， 长度:%d \n", cap(s3), len(s3)) // 容量:8， 长度:3

// 特殊情况，如果切片类型为interface{}时，可以存放任意的数据类型
s4 := []interface{}{1, 2, 3.14, "王安石"}
fmt.Println(s4) // [1 2 3.14 王安石]
```

###### c、Python

```python
# Python的List中可以存放任意类型的数据
names = ["王安石", "苏轼", 10, True, [1, 2]]
print(names) # ['王安石', '苏轼', 10, True, [1, 2]]
```

###### d、JavaScript

```javascript
// JavaScript 的Array可以包含任意数据类型

// 方式一：推荐
let arr = [1, 2, 3.14, 'Hello', null, true, [2, false, 'sk']]
console.log(arr) // [ 1, 2, 3.14, 'Hello', null, true, [ 2, false, 'sk' ] ]

// 方式二：不推荐
let arr2 = new Array()  // 不推荐
console.log(arr2) // []
```

##### 2、遍历

###### a、Java

```java
var names = Arrays.asList("王安石", "苏轼");
// 方式一：
for (int i = 0, len = names.size(); i < len; i++) {
    System.out.println(names.get(i));
}

// 方式二：
var ite = names.iterator();
while (ite.hasNext()) {
    System.out.println(ite.next());
}

// 方式三
for(var name:names){
    System.out.println(name);
}
```

###### b、Go

```go
names := []string{"王安石", "苏轼"}
// 方式一
for i := 0; i < len(names); i++ {
	fmt.Println(names[i])
}

// 方式二
for index, name := range names {
	fmt.Println(index, name)
}
```

###### c、Python

```python
names = ["王安石", "苏轼"]

# 方式一
for name in names:
    print(name)

# 方式二：带有index (0, '王安石') (1, '苏轼')
for name in enumerate(names):
    print(name)

# 方式三：
for name in iter(names):
    print(name)

# 方式四
for i in range(len(names)):
    print(i, names[i])
```

###### d、JavaScript

```javascript
let names = ["王安石", "苏轼"]
// 方式一：for/while 根据数组长度遍历
for (let i = 0, len = names.length; i < len; i++) {
    console.log(names[i])
}

// 方式二： for...in 可以遍历对象/数组。遍历数组时也会遍历非数字键名，所以不推荐for...in遍历数组
for (let key in names) {
    console.log(names[key])
}

// 方式三：for...of (ES6)
for(let name of names){
    console.log(name)
}

// 方式四：forEach()方法
names.forEach(name=>console.log(name))
```

##### 3、增删改

###### a、Java

```java
var names = new ArrayList<String>();
// 1. 添加元素
names.add("王安石");  // 方式一：添加到末尾
names.add(0, "苏轼"); // 方式二：添加到指定位置
System.out.println(names); // [苏轼, 王安石]

// 2. 删除元素
names.remove("王安石");  // 方式一：根据元素
System.out.println(names); // [苏轼]
names.remove(0); // 方式二：根据索引
System.out.println(names); // []
names.add(0, "欧阳修");
var ite = names.iterator();
while (ite.hasNext()) {
    String name = ite.next();
    if ("欧阳修".equals(name)) {
        ite.remove();   // 方式三：使用迭代器删除
    }
}
System.out.println(names); // []

// 3. 修改元素
names.add("王安石");  // [王安石]
System.out.println(names);
names.set(0, "欧阳修");
System.out.println(names); // [欧阳修]
```

###### b、Go

```go
// 1. 增加元素
names = []string{}
names = append(names, "王安石", "曾巩")             // 方式一：在末尾插入
fmt.Printf("指向地址:%p， 切片内容：%s\n", names, names) //指向地址:0xc00005a060， 切片内容：[王安石 曾巩]
names = append(names[:1], "苏轼")                // 方式二：在指定位置插入，插入时会覆盖后面位置元素
fmt.Printf("指向地址:%p， 切片内容：%s\n", names, names) //指向地址:0xc00005a060， 切片内容：[王安石 苏轼]

// 2. 删除元素
names = append(names, "柳宗元")
fmt.Printf("指向地址:%p， 切片内容：%s\n", names, names) // 指向地址:0xc0000200c0， 切片内容：[王安石 苏轼 柳宗元]
names = append(names[:1], names[2:]...)        // 删除第二个元素 [0,1)+[2,结束+1)
fmt.Printf("指向地址:%p， 切片内容：%s\n", names, names) // 指向地址:0xc0000200c0， 切片内容：[王安石 柳宗元]

// 3. 修改元素
names[1] = "李元龙"
fmt.Println(names) // [王安石 李元龙]
```

###### c、Python

```python
names = ["王安石"]
# 1. 增加元素
names.append("苏轼")  # 方式一：在末尾添加
names.insert(0, "柳宗元")  # 方式二：在指定位置添加
print(names)  # ['柳宗元', '王安石', '苏轼']

# 2. 删除元素
names.pop()  # 方式一：在末尾删除
print(names)  # ['柳宗元', '王安石']
names.pop(0)  # 方式二：在指定位置删除
print(names)  # ['王安石']

# 3. 修改元素
names[0] = "周润发"
print(names)  # ['周润发']
```

###### d、JavaScript

```javascript
names = ["王安石"]
// 1. 增加元素
names.push("苏轼")    // 方式一：在末尾添加元素
names.unshift("柳宗元") // 方式二：在头部增加元素
console.log(names)  // [ '柳宗元', '王安石', '苏轼' ]

// 2. 删除元素
names.pop()  // 方式一：从末尾删除元素
names.shift()   // 方式二：从头部删除数据
console.log(names) // [ '王安石' ]

// 3. 修改元素
names[0] = "周润发"
console.log(names)  // [ '周润发' ]
```

##### 4、排序

###### a、Java

```java
var numbers = Arrays.asList(4, 6, 8, 9, 1, 2);
numbers.sort((e1, e2) -> e1.compareTo(e2));
System.out.println(numbers); // [1, 2, 4, 6, 8, 9]
```

###### b、Go

```go
numbers := []int{4, 6, 8, 9, 1, 2}
sort.Ints(numbers)
fmt.Println(numbers) // [1 2 4 6 8 9]
```

###### c、Python

```python
numbers = [4, 6, 8, 9, 1, 2]
numbers.sort()
print(numbers)  # [1, 2, 4, 6, 8, 9]
```

###### d、JavaScript

```javascript
numbers = [4, 6, 8, 9, 1, 2, 2]
numbers.sort()
console.log(numbers)    // [ 1, 2, 2, 4, 6, 8, 9 ]
numbers.sort((a, b) => {
    if (a > b) {
        return -1;
    } else if (a < b) {
        return 1
    } else {
        return 0;
    }
})
console.log(numbers)  // [9, 8, 6, 4, 2, 2, 1]
```

#### 2.3.3、Map 字典

Java中的Map是定义为接口，jdk包括用户都可以基于该接口实现自己的Map实现类。当前Java中实现Map接口的数据结构有：

- Hashtable：线程安全；对象锁，所有方法sync
- HashMap：非线程安全；允许存在一条键为null的记录；底层实现为数组+链表(可演变为红黑树)
- TreeMap：非线程安全；不允许key为null；按key进行排序，可以自定义Comparator
- LinkedHashMap：非线程安全；保证插入的顺序
- ConcurrentHashMap：线程安全；采用分段锁
- ConcurrentSkipListMap：线程安全；默认按照key值升序；
- ......

参考： https://www.cnblogs.com/www-123456/p/10890855.html

Go、Python、JavaScript的类Map都是编程语言内置的，Go语言的map、Python的<class 'dict'>、JavaScript的Map都是语言内置的，提供容量动态增长特性，并提供丰富的操作接口。

##### 1、创建

###### a、Java

```java
// 方式一：
final Map<String, String> nameAlis = new HashMap<>();
nameAlis.put("苏轼", "东坡居士");
nameAlis.put("诸葛亮", "孔明");

// 方式二：
final Map<String, String> nameAlis2 = new HashMap<>() {{
    put("苏轼", "东坡居士");
    put("诸葛亮", "孔明");
}};

// 方式三：JDK9
final Map<String, String> nameAlis3 = Map.of("苏轼", "东坡居士", "诸葛亮", "孔明");
```

###### b、Go

```go
// 方式一：先声明，在创建
var nameAlias map[string]string // 只有声明，没有初始化，值为nil
nameAlias = make(map[string]string)
nameAlias["苏轼"] = "东坡居士"
nameAlias["诸葛亮"] = "孔明"

// 方式二：
var nameAlias2 = map[string]string{"苏轼": "东坡居士", "诸葛亮": "孔明"}
fmt.Println(nameAlias2) // map[苏轼:东坡居士 诸葛亮:孔明]
```

###### c、Python

```python
nameAlias = {"苏轼": "东坡居士"}
nameAlias["诸葛亮"] = "孔明"
print(nameAlias) // {'苏轼': '东坡居士', '诸葛亮': '孔明'}
```

###### d、JavaScript

```javascript
// 方式一：推荐
nameAlias = new Map()
nameAlias.set("苏轼", "东坡居士")
nameAlias.set("诸葛亮", "孔明")
nameAlias["周润发"] = "发哥"

console.log(nameAlias.constructor) // [Function: Map]
console.log(nameAlias)
// Map(2) { '苏轼' => '东坡居士', '诸葛亮' => '孔明', '周润发': '发哥' }
// 2：表示Map对象有两个元素，key分别是苏轼、诸葛亮。 周润发这个属性是作为Object属性，并不是Map的key


// 方式二： 类似Map，但其实是Object
nameAlias2 = {"苏轼": "东坡居士"}
nameAlias2["诸葛亮"] = "孔明"
console.log(nameAlias2.constructor)  // [Function: Object]
console.log(nameAlias2)  // { '苏轼': '东坡居士', '诸葛亮': '孔明' }
```

##### 2、遍历

###### a、Java

```java
final Map<String, String> nameAlis = new HashMap<>();
nameAlis.put("苏轼", "东坡居士");
nameAlis.put("诸葛亮", "孔明");

// 方式一：推荐
for (var item : nameAlis.entrySet()) {
    System.out.println(item.getKey() + ":" + item.getValue());
}

// 方式二：不推荐
for (var key : nameAlis.keySet()) {
    System.out.println(key + ":" + nameAlis.get(key));
}

// 方式三：
nameAlis.forEach((key, value) -> System.out.println(key + ":" + value));
```

###### b、Go

```go
var nameAlias3 = map[string]string{"苏轼": "东坡居士", "诸葛亮": "孔明"}
for k, v := range nameAlias3 {
	fmt.Println(k, ":", v)
}
```

###### c、Python

```python
nameAlias = {"苏轼": "东坡居士", "诸葛亮": "孔明"}
# 方式一：
for key in nameAlias:
    print(key + ":" + nameAlias[key])

# 方式二 推荐
for key, value in nameAlias.items():
    print(key + ":" + value)
```

###### d、JavaScript

```javascript
nameAlias3 = new Map([["test", "testValue"]])
nameAlias3.set("苏轼", "东坡居士")
nameAlias3.set("诸葛亮", "孔明")
nameAlias3["周润发"] = "发哥"

// 方式一：能遍历Map中的key和value，无法遍历Object的key、value属性
for (let item of nameAlias3) {
    console.log(item[0] + ":" + item[1])
}

// 方式二：能遍历Map中的key和value，无法遍历Object的key、value属性
nameAlias3.forEach(function (value, key, map) {
    console.log(key + ":" + value)
})

// 无法遍历Map中的key和value，能遍历Object的key、value属性
for (let key in nameAlias3) {
    console.log(key + ":" + nameAlias3[key])
}
```

##### 3、增删查

###### a、Java

```java
final Map<String, String> nameAlis = new HashMap<>();

// 1. 增加key/value
nameAlis.put("苏轼", "东坡居士"); // 方式一：有就覆盖，没有就增加
nameAlis.putIfAbsent("苏轼", "苏轼"); // 方式二：如果key不存在就添加，存在就不增加
// 方式三：如果不存在，就给他计算出一个值，并put进去
nameAlis.computeIfAbsent("周润发", (key) -> key + "发哥");
// 方式四：如果以及存在，重新计算出一个值，并put进去，key不变
nameAlis.computeIfPresent("苏轼", (key, value) -> key + value);
System.out.println(nameAlis); // {周润发=周润发发哥, 苏轼=苏轼东坡居士}
// 方式五：
//nameAlis.compute("周慧敏",)
// 方式六：
//nameAlis.putAll();

// 2. 删除
nameAlis.remove("周慧敏");
nameAlis.remove("周慧敏", "周慧敏");

// 3. 查询
nameAlis.get("周慧敏");
nameAlis.getOrDefault("周慧敏", "默认值周慧敏");
```

###### b、Go

```go
var nameAlias4 = map[string]string{}
// 1. 增加
nameAlias4["苏轼"] = "东坡居士" // key不存在则增加，否则修改
nameAlias4["诸葛亮"] = "孔明"

// 2. 删除
delete(nameAlias4, "苏轼")

// 3. 查询
alias := nameAlias4["诸葛亮"]      // 方式一：直接获取
alias2, ok := nameAlias4["诸葛亮"] // 方式二：判断获取
if ok {
	fmt.Println(alias2)
}
fmt.Println(alias)
fmt.Println(nameAlias4)
```

###### c、Python

```python
# 1. 增加
nameAlias2 = {"诸葛亮": "孔明"}  # 方式一：创建就增加
nameAlias2["苏轼"] = "东坡居士"  # 方式二：添加

# 2. 删除
nameAlias2.pop("诸葛亮")

# 3. 获取
nameAlias2["苏轼"]  # 方式一：不推荐，如果key不存在，会抛TypeError异常
nameAlias2.get("苏轼")  # 方式二：推荐，如果可以不存在，返回None
nameAlias2.get("诸葛亮", "孔明")  # 方式三：推荐，如果key不存在，返回指定的值
```

###### d、JavaScript

```javascript
nameAlias = new Map()
// 1.增加
nameAlias.set("苏轼", "东坡居士")
nameAlias.set("诸葛亮", "孔明")

// 2.删除
nameAlias.delete("诸葛亮")

// 3.查询
nameAlias.has("苏格兰")  // 判断是是否存在
nameAlias.get("苏格兰")  // 如果不存在，返回 undefined
```

#### 2.3.4、Set 集合

##### 1、创建

###### a、Java

```java

```

###### b、Go

```go

```

###### c、Python

```python

```

###### d、JavaScript

```javascript

```



##### 2、遍历

###### a、Java

```java

```

###### b、Go

```go

```

###### c、Python

```python

```

###### d、JavaScript

```javascript

```



#### 2.3.5、元组

## 3、字符串和编码

Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。现代操作系统和大多数编程语言都直接支持Unicode。

ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。

如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。

所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的`UTF-8`编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间：

| 字符 | ASCII    | Unicode           | UTF-8                      |
| :--- | :------- | :---------------- | :------------------------- |
| A    | 01000001 | 00000000 01000001 | 01000001                   |
| 中   | 不存在   | 01001110 00101101 | 11100100 10111000 10101101 |

**在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。**

参考： https://www.liaoxuefeng.com/wiki/1016959663602400/1017075323632896

## 4、程序结构

### 4.1、选择结构
### 4.2、循环结构

# 二、函数
## 1、参数
## 2、返回值

# 三、面向对象

# 四、并发编程

